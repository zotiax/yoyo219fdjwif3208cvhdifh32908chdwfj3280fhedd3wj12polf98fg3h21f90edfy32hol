--[[
    Made by samet

    Assign different flags to each element to prevent from configs overriding eachother
    Example script is at the bottom

    Documentation:
    function Library:Window(Data: table
        Name/name: string,
        Size/size: UDim2
    )

    function Window:Page(Data: table
        Name/name: string,
        Columns/columns: number,
        SubTabs/subtabs: boolean
    )

    function Page:SubPage(Data: tabled
        Icon/icon: string,
        Columns/columns: number
    )

    function Page:Section(Data: table
        Name/name: string,
        Side/side: number,
    )

    function Page:MultiSection(Data: table
        Sections/sections: table,
        Side/side: number
    )

    function Page:ScrollableSection(Data: table
        Name/name: string,
        Side/side: number,
        Size/size: number
    )

    function Section:Divider()

    function Section:Label(Data: table
        Name/name: string,
        Alignment/alignment: string
    )

    function Section:Toggle(Data: table
        Name/name: string,
        Default/default: boolean,
        Flag/flag: string,
        Callback/callback: function
    )

    function Section:Button(Data: table
        Name/name: string,
        Callback/callback: function
    )

    function Section:Slider(Data: table
        Name/name: string,
        Min/min: number,
        Max/max: number,
        Decimals/decimals: number,
        Default/default: number,
        Suffix/suffix: string,
        Flag/flag: string,
        Callback/callback: function
    )

    function Section:Textbox(Data: table
        Name/name: string,
        Default/default: string,
        Placeholder/placeholder: string,
        Flag/flag: string,
        Callback/callback: function
    )

    function Section:Dropdown(Data: table
        Name/name: string,
        Items/items: table,
        Default/default: string,
        Flag/flag: string,
        Multi/multi: boolean,
        Callback/callback: function
    )

    function Section:Listbox(Data: table
        Size/size: number,
        Items/items: table,
        Default/default: string,
        Multi/multi: boolean,
        Flag/flag: string,
        Callback/callback: function
    )

    function Label:Keybind(Data: table
        Name/name: string,
        Mode/mode: string,
        Default/default: EnumItem,
        Flag/flag: string,
        Callback/callback: function
    )

    function Label:Colorpicker(Data: table
        Name/name: string,
        Default/default: Color3,
        Alpha/alpha: boolean,
        Flag/flag: string,
        Callback/callback: function
    )

    function Toggle:Colorpicker(Data: table
        Name/name: string,
        Default/default: Color3,
        Alpha/alpha: boolean,
        Flag/flag: string,
        Callback/callback: function
    )

    function Toggle:Keybind(Data: table
        Name/name: string,
        Mode/mode: string,
        Default/default: EnumItem,
        Flag/flag: string,
        Callback/callback: function
    )

    function Sections:Textbox(Data: table
        Name/name: string,
        Default/default: string,
        Placeholder/placeholder: string,
        Flag/flag: string,
        Callback/callback: function
    )

    function Library:Watermark(Name: string)
    function Library:Notification(Text: string, Duration: number, Color: Color3, Icon: table)
    function Library:KeybindList()
]]

local LoadingTick = os.clock()

if getgenv().Library then 
    getgenv().Library:Unload()
end

local Library do
    local UserInputService = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local HttpService = game:GetService("HttpService")
    local TweenService = game:GetService("TweenService")
    local CoreGui = cloneref and cloneref(game:GetService("CoreGui")) or game:GetService("CoreGui")

    gethui = gethui or function()
        return CoreGui
    end

    local LocalPlayer = Players.LocalPlayer
    local Camera = Workspace.CurrentCamera
    local Mouse = LocalPlayer:GetMouse()

    local FromRGB = Color3.fromRGB
    local FromHSV = Color3.fromHSV
    local FromHex = Color3.fromHex

    local RGBSequence = ColorSequence.new
    local RGBSequenceKeypoint = ColorSequenceKeypoint.new

    local NumSequence = NumberSequence.new
    local NumSequenceKeypoint = NumberSequenceKeypoint.new

    local UDim2New = UDim2.new
    local UDimNew = UDim.new
    local Vector2New = Vector2.new

    local InstanceNew = Instance.new

    local MathClamp = math.clamp
    local MathFloor = math.floor

    local TableInsert = table.insert
    local TableFind = table.find
    local TableRemove = table.remove
    local TableConcat = table.concat
    local TableUnpack = table.unpack

    local StringFormat = string.format
    local StringFind = string.find
    local StringGSub = string.gsub

    Library = {
        Flags = { },
        
        Theme = {
            ["Background"] = FromRGB(10, 10, 10),
            ["Inline"] = FromRGB(10, 10, 10),
            ["Page Background"] = FromRGB(10, 10, 10),
            ["Border"] = FromRGB(10, 10, 10),
            ["Outline"] = FromRGB(10, 10, 10),
            ["Accent"] = FromRGB(255,182,193),
            ["Element"] = FromRGB(10, 10, 10),
            ["Hovered Element"] = FromRGB(40, 40, 43),
            ["Text"] = FromRGB(215, 215, 215),
            ["Text Border"] = FromRGB(0, 0, 0)
        },

        MenuKeybind = Enum.KeyCode.Z, 

        Tween = {
            Time = 0.3,
            Style = Enum.EasingStyle.Exponential,
            Direction = Enum.EasingDirection.Out
        },

        Folders = {
            Directory = "scriptname",
            Configs = "scriptname/Configs",
            Assets = "scriptname/Assets"
        },

        Images = { -- you're welcome to reupload the images and replace it with your own links
            ["Saturation"] = {"Saturation.png", "https://github.com/sametexe001/images/blob/main/saturation.png?raw=true" },
            ["Value"] = { "Value.png", "https://github.com/sametexe001/images/blob/main/value.png?raw=true" },
            ["Hue"] = { "Hue.png", "https://github.com/sametexe001/images/blob/main/hue.png?raw=true" },
            ["Scrollbar"] =  { "Scrollbar.png", "https://github.com/sametexe001/images/blob/main/scrollbar.png?raw=true" },
            ["Checkers"] = { "Checkers.png", "https://github.com/sametexe001/images/blob/main/checkers.png?raw=true" },
            ["Resize"] = { "Resize.png", "https://github.com/sametexe001/images/blob/main/resize.png?raw=true" },
        },

        -- Ignore below
        Pages = { },
        Sections = { },
        Connections = { },
        Threads = { },
        ThemeMap = { },
        ThemeItems = { },

        SetFlags = { },

        UnnamedConnections = 0,
        UnnamedFlags = 0,

        Holder = nil,
        NotifHolder = nil,
        Font = nil,
        KeyList = nil,

        CurrentColorpicker = nil
    }

    Library.__index = Library
    Library.Sections.__index = Library.Sections
    Library.Pages.__index = Library.Pages

    local Keys = {
        ["Unknown"]           = "Unknown",
        ["Backspace"]         = "Back",
        ["Tab"]               = "Tab",
        ["Clear"]             = "Clear",
        ["Return"]            = "Return",
        ["Pause"]             = "Pause",
        ["Escape"]            = "Escape",
        ["Space"]             = "Space",
        ["QuotedDouble"]      = '"',
        ["Hash"]              = "#",
        ["Dollar"]            = "$",
        ["Percent"]           = "%",
        ["Ampersand"]         = "&",
        ["Quote"]             = "'",
        ["LeftParenthesis"]   = "(",
        ["RightParenthesis"]  = " )",
        ["Asterisk"]          = "*",
        ["Plus"]              = "+",
        ["Comma"]             = ",",
        ["Minus"]             = "-",
        ["Period"]            = ".",
        ["Slash"]             = "`",
        ["Three"]             = "3",
        ["Seven"]             = "7",
        ["Eight"]             = "8",
        ["Colon"]             = ":",
        ["Semicolon"]         = ";",
        ["LessThan"]          = "<",
        ["GreaterThan"]       = ">",
        ["Question"]          = "?",
        ["Equals"]            = "=",
        ["At"]                = "@",
        ["LeftBracket"]       = "LeftBracket",
        ["RightBracket"]      = "RightBracked",
        ["BackSlash"]         = "BackSlash",
        ["Caret"]             = "^",
        ["Underscore"]        = "_",
        ["Backquote"]         = "`",
        ["LeftCurly"]         = "{",
        ["Pipe"]              = "|",
        ["RightCurly"]        = "}",
        ["Tilde"]             = "~",
        ["Delete"]            = "Delete",
        ["End"]               = "End",
        ["KeypadZero"]        = "Keypad0",
        ["KeypadOne"]         = "Keypad1",
        ["KeypadTwo"]         = "Keypad2",
        ["KeypadThree"]       = "Keypad3",
        ["KeypadFour"]        = "Keypad4",
        ["KeypadFive"]        = "Keypad5",
        ["KeypadSix"]         = "Keypad6",
        ["KeypadSeven"]       = "Keypad7",
        ["KeypadEight"]       = "Keypad8",
        ["KeypadNine"]        = "Keypad9",
        ["KeypadPeriod"]      = "KeypadP",
        ["KeypadDivide"]      = "KeypadD",
        ["KeypadMultiply"]    = "KeypadM",
        ["KeypadMinus"]       = "KeypadM",
        ["KeypadPlus"]        = "KeypadP",
        ["KeypadEnter"]       = "KeypadE",
        ["KeypadEquals"]      = "KeypadE",
        ["Insert"]            = "Insert",
        ["Home"]              = "Home",
        ["PageUp"]            = "PageUp",
        ["PageDown"]          = "PageDown",
        ["RightShift"]        = "RightShift",
        ["LeftShift"]         = "LeftShift",
        ["RightControl"]      = "RightControl",
        ["LeftControl"]       = "LeftControl",
        ["LeftAlt"]           = "LeftAlt",
        ["RightAlt"]          = "RightAlt"
    }

    -- Files 
    for _, FileName in Library.Folders do
        if not isfolder(FileName) then
            makefolder(FileName)
        end
    end

    for _, ImageData in Library.Images do
        local ImageName = ImageData[1]
        local ImageLink = ImageData[2]
        
        if not isfile(Library.Folders.Assets .. "/" .. ImageName) then
            writefile(Library.Folders.Assets .. "/" .. ImageName, game:HttpGet(ImageLink))
        end
    end

    local Tween = { } do
        Tween.__index = Tween

        Tween.Create = function(self, Item, Info, Goal, IsRawItem)
            Item = IsRawItem and Item or Item.Instance
            Info = Info or TweenInfo.new(Library.Tween.Time, Library.Tween.Style, Library.Tween.Direction)

            local NewTween = {
                Tween = TweenService:Create(Item, Info, Goal),
                Info = Info,
                Goal = Goal,
                Item = Item
            }

            NewTween.Tween:Play()

            setmetatable(NewTween, Tween)

            return NewTween
        end

        Tween.Get = function(self)
            if not self.Tween then 
                return
            end

            return self.Tween, self.Info, self.Goal
        end

        Tween.Pause = function(self)
            if not self.Tween then 
                return
            end

            self.Tween:Pause()
        end

        Tween.Play = function(self)
            if not self.Tween then 
                return
            end

            self.Tween:Play()
        end

        Tween.Clean = function(self)
            if not self.Tween then 
                return
            end

            Tween:Pause()
            self = nil
        end
    end

    local Instances = { } do
        Instances.__index = Instances

        Instances.Create = function(self, Class, Properties)
            local NewItem = {
                Instance = InstanceNew(Class),
                Properties = Properties,
                Class = Class
            }

            setmetatable(NewItem, Instances)

            for Property, Value in NewItem.Properties do
                NewItem.Instance[Property] = Value
            end

            return NewItem
        end

        Instances.Border = function(self)
            if not self.Instance then 
                return
            end

            local Item = self.Instance
            local UIStroke = Instances:Create("UIStroke", {
                Parent = Item,
                Color = Library.Theme.Border,
                Thickness = 1,
                LineJoinMode = Enum.LineJoinMode.Miter
            })

            UIStroke:AddToTheme({Color = "Border"})

            return UIStroke
        end

        Instances.AddToTheme = function(self, Properties)
            if not self.Instance then 
                return
            end

            Library:AddToTheme(self, Properties)
        end

        Instances.ChangeItemTheme = function(self, Properties)
            if not self.Instance then 
                return
            end

            Library:ChangeItemTheme(self, Properties)
        end

        Instances.Connect = function(self, Event, Callback, Name)
            if not self.Instance then 
                return
            end

            if not self.Instance[Event] then 
                return
            end

            return Library:Connect(self.Instance[Event], Callback, Name)
        end

        Instances.Tween = function(self, Info, Goal)
            if not self.Instance then 
                return
            end

            return Tween:Create(self, Info, Goal)
        end

        Instances.Disconnect = function(self, Name)
            if not self.Instance then 
                return
            end

            return Library:Disconnect(Name)
        end

        Instances.Clean = function(self)
            if not self.Instance then 
                return
            end

            self.Instance:Destroy()
            self = nil
        end

        Instances.MakeDraggable = function(self)
            if not self.Instance then 
                return
            end

            local Gui = self.Instance

            local Dragging = false 
            local DragStart
            local StartPosition 

            local Set = function(Input)
                local DragDelta = Input.Position - DragStart
                self:Tween(TweenInfo.new(0.16, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(StartPosition.X.Scale, StartPosition.X.Offset + DragDelta.X, StartPosition.Y.Scale, StartPosition.Y.Offset + DragDelta.Y)})
            end

            self:Connect("InputBegan", function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                    Dragging = true

                    DragStart = Input.Position
                    StartPosition = Gui.Position
                end
            end)

            self:Connect("InputEnded", function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                    Dragging = false
                end
            end)

            Library:Connect(UserInputService.InputChanged, function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseMovement or Input.UserInputType == Enum.UserInputType.Touch then
                    if Dragging then
                        Set(Input)
                    end
                end
            end)

            return Dragging
        end

        Instances.MakeResizeable = function(self, Minimum, Maximum)
            if not self.Instance then 
                return
            end

            local Gui = self.Instance

            local Resizing = false 
            local Start = UDim2New()
            local Delta = UDim2New()
            local ResizeMax = Gui.Parent.AbsoluteSize - Gui.AbsoluteSize

            local ResizeButton = Instances:Create("TextButton", {
				Parent = Gui,
				AnchorPoint = Vector2New(1, 1),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(0, 8, 0, 8),
				Position = UDim2New(1, 0, 1, 0),
                Name = "\0",
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				AutoButtonColor = false,
                Visible = true,
                Text = ""
			})

            ResizeButton:Connect("InputBegan", function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                    Resizing = true

                    Start = Gui.Size - UDim2New(0, Input.Position.X, 0, Input.Position.Y)
                end
            end)

            ResizeButton:Connect("InputEnded", function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
                    Resizing = false
                end
            end)

            Library:Connect(UserInputService.InputChanged, function(Input)
                if Input.UserInputType == Enum.UserInputType.MouseMovement and Resizing then
					ResizeMax = Maximum or Gui.Parent.AbsoluteSize - Gui.AbsoluteSize

					Delta = Start + UDim2New(0, Input.Position.X, 0, Input.Position.Y)
					Delta = UDim2New(0, math.clamp(Delta.X.Offset, Minimum.X, ResizeMax.X), 0, math.clamp(Delta.Y.Offset, Minimum.Y, ResizeMax.Y))

					Tween:Create(Gui, TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = Delta}, true)
                end
            end)

            return Resizing
        end

        Instances.OnHover = function(self, Function)
            if not self.Instance then 
                return
            end
            
            return Library:Connect(self.Instance.MouseEnter, Function)
        end

        Instances.OnHoverLeave = function(self, Function)
            if not self.Instance then 
                return
            end
            
            return Library:Connect(self.Instance.MouseLeave, Function)
        end
    end

    local CustomFont = { } do
        function CustomFont:New(Name, Weight, Style, Data)
            if isfile(Library.Folders.Assets .. "/" .. Name .. ".json") then
                return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
            end

            if not isfile(Library.Folders.Assets .. "/" .. Name .. ".ttf") then 
                writefile(Library.Folders.Assets .. "/" .. Name .. ".ttf", game:HttpGet(Data.Url))
            end

            local FontData = {
                name = Name,
                faces = { {
                    name = "Regular",
                    weight = Weight,
                    style = Style,
                    assetId = getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".ttf")
                } }
            }

            writefile(Library.Folders.Assets .. "/" .. Name .. ".json", HttpService:JSONEncode(FontData))
            return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
        end

        function CustomFont:Get(Name)
            if isfile(Library.Folders.Assets .. "/" .. Name .. ".json") then
                return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
            end
        end

        CustomFont:New("Windows-XP-Tahoma", 200, "Regular", {
            Url = "https://github.com/sametexe001/luas/raw/refs/heads/main/fonts/windows-xp-tahoma.ttf"
        })

        Library.Font = CustomFont:Get("Windows-XP-Tahoma")
    end

    Library.Holder = Instances:Create("ScreenGui", {
        Parent = gethui(),
        Name = "\0",
        ResetOnSpawn = false
    })

    Library.NotifHolder = Instances:Create("Frame", {
        Parent = Library.Holder.Instance,
        BorderColor3 = FromRGB(0, 0, 0),
        AnchorPoint = Vector2New(0.5, 0),
        BackgroundTransparency = 1,
        Position = UDim2New(0.5, 0, 0, 0),
        Name = "\0",
        Size = UDim2New(0.34, 0, 1, -14),
        BorderSizePixel = 0,
        BackgroundColor3 = FromRGB(255, 255, 255)
    }) 
    
    Instances:Create("UIListLayout", {
        Parent = Library.NotifHolder.Instance,
        VerticalAlignment = Enum.VerticalAlignment.Top,
        SortOrder = Enum.SortOrder.LayoutOrder,
        HorizontalAlignment = Enum.HorizontalAlignment.Center,
        Padding = UDimNew(0, 10)
    }) 

    Library.GetImage = function(self, Image)
        local ImageData = self.Images[Image]

        if not ImageData then 
            return
        end

        return getcustomasset(self.Folders.Assets .. "/" .. ImageData[1])
    end

    Library.Round = function(self, Number, Float)
        local Multiplier = 1 / (Float or 1)
        return MathFloor(Number * Multiplier) / Multiplier
    end

    Library.GetTransparencyPropertyFromItem = function(self, Item)
        if Item:IsA("Frame") then
            return { "BackgroundTransparency" }
        elseif Item:IsA("TextLabel") or Item:IsA("TextButton") then
            return { "TextTransparency", "BackgroundTransparency" }
        elseif Item:IsA("ImageLabel") or Item:IsA("ImageButton") then
            return { "BackgroundTransparency", "ImageTransparency" }
        elseif Item:IsA("ScrollingFrame") then
            return { "BackgroundTransparency", "ScrollBarImageTransparency" }
        elseif Item:IsA("TextBox") then
            return { "TextTransparency", "BackgroundTransparency" }
        elseif Item:IsA("UIStroke") then 
            return { "Transparency" }
        end
    end

    Library.FadeItem = function(self, Item, Property, Visibility, Speed)
        local OldTransparency = Item[Property]
        Item[Property] = Visibility and 1 or OldTransparency

        local NewTween = Tween:Create(Item, TweenInfo.new(Speed or Library.Tween.Time, Library.Tween.Style, Library.Tween.Direction), {
            [Property] = Visibility and OldTransparency or 1
        }, true)

        Library:Connect(NewTween.Tween.Completed, function()
            if not Visibility then 
                task.wait()
                Item[Property] = OldTransparency
            end
        end)

        return NewTween
    end

    Library.Unload = function(self)
        for Index, Value in self.Connections do 
            Value.Connection:Disconnect()
        end

        for Index, Value in self.Threads do 
            coroutine.close(Value)
        end

        if self.Holder then 
            self.Holder:Clean()
        end

        Library = nil 
        getgenv().Library = nil
    end

    Library.Thread = function(self, Function)
        local NewThread = coroutine.create(Function)
        
        coroutine.wrap(function()
            coroutine.resume(NewThread)
        end)()

        TableInsert(self.Threads, NewThread)

        return NewThread
    end
    
    Library.SafeCall = function(self, Function, ...)
        local Arguements = { ... }
        local Success, Result = pcall(Function, TableUnpack(Arguements))

        if not Success then
            Library:Notification("Error caught in function, report this to the devs:\n"..Result, 5, FromRGB(255, 0, 0))
            warn(Result)
            return false
        end

        return Success
    end

    Library.Connect = function(self, Event, Callback, Name)
        Name = Name or StringFormat("Connection_%s_%s", self.UnnamedConnections + 1, HttpService:GenerateGUID(false))

        local NewConnection = {
            Event = Event,
            Callback = Callback,
            Name = Name,
            Connection = nil
        }

        Library:Thread(function()
            NewConnection.Connection = Event:Connect(Callback)
        end)

        TableInsert(self.Connections, NewConnection)
        return NewConnection
    end

    Library.Disconnect = function(self, Name)
        for _, Connection in self.Connections do 
            if Connection.Name == Name then
                Connection.Connection:Disconnect()
                break
            end
        end
    end

    Library.NextFlag = function(self)
        local FlagNumber = self.UnnamedFlags + 1
        return StringFormat("Flag Number %s %s", FlagNumber, HttpService:GenerateGUID(false))
    end

    Library.AddToTheme = function(self, Item, Properties)
        Item = Item.Instance or Item 

        local ThemeData = {
            Item = Item,
            Properties = Properties,
        }

        for Property, Value in ThemeData.Properties do
            if type(Value) == "string" then
                Item[Property] = self.Theme[Value]
            end
        end

        TableInsert(self.ThemeItems, ThemeData)
        self.ThemeMap[Item] = ThemeData
    end

    Library.GetConfig = function(self)
        local Config = { } 

        local Success, Result = Library:SafeCall(function()
            for Index, Value in Library.Flags do 
                if type(Value) == "table" and Value.Key then
                    Config[Index] = {Key = tostring(Value.Key), Mode = Value.Mode}
                elseif type(Value) == "table" and Value.Color then
                    Config[Index] = {Color = "#" .. Value.HexValue, Alpha = Value.Alpha}
                else
                    Config[Index] = Value
                end
            end
        end)

        return HttpService:JSONEncode(Config)
    end

    Library.LoadConfig = function(self, Config)
        local Decoded = HttpService:JSONDecode(Config)

        local Success, Result = Library:SafeCall(function()
            for Index, Value in Decoded do 
                local SetFunction = Library.SetFlags[Index]

                if not SetFunction then
                    continue
                end

                if type(Value) == "table" and Value.Key then 
                    SetFunction(Value)
                elseif type(Value) == "table" and Value.Color then
                    SetFunction(Value.Color, Value.Alpha)
                else
                    SetFunction(Value)
                end
            end
        end)

        if Success then 
            Library:Notification("Successfully loaded config", 5, Color3.fromRGB(0, 255, 0))
        end
    end

    Library.DeleteConfig = function(self, Config)
        if isfile(Library.Folders.Configs .. "/" .. Config) then 
            delfile(Library.Folders.Configs .. "/" .. Config)
            Library:Notification("Deleted config " .. Config .. ".json", 5, Color3.fromRGB(0, 255, 0))
        end
    end

    Library.SaveConfig = function(self, Config)
        if isfile(Library.Folders.Directory .. "/" .. Library.Folders.Configs .. "/" .. Config .. ".json") then
            writefile(Library.Folders.Directory .. "/" .. Library.Folders.Configs .. "/" .. Config .. ".json", Library:GetConfig())
            Library:Notification("Saved config " .. Config .. ".json", 5, Color3.fromRGB(0, 255, 0))
        end
    end

    Library.RefreshConfigsList = function(self, Element)
        local CurrentList = { }
        local List = { }

        local ConfigFolderName = StringGSub(Library.Folders.Configs, Library.Folders.Directory .. "/", "")

        for Index, Value in listfiles(Library.Folders.Configs) do
            local FileName = StringGSub(Value, Library.Folders.Directory .. "\\" .. ConfigFolderName .. "\\", "")
            List[Index] = FileName
        end

        local IsNew = #List ~= CurrentList

        if not IsNew then
            for Index = 1, #List do
                if List[Index] ~= CurrentList[Index] then
                    IsNew = true
                    break
                end
            end
        else
            CurrentList = List
            Element:Refresh(CurrentList)
        end
    end

    Library.ChangeItemTheme = function(self, Item, Properties)
        Item = Item.Instance or Item

        if not self.ThemeMap[Item] then 
            return
        end

        self.ThemeMap[Item].Properties = Properties
        self.ThemeMap[Item] = self.ThemeMap[Item]
    end

    Library.ChangeTheme = function(self, Theme, Color)
        self.Theme[Theme] = Color

        for _, Item in self.ThemeItems do
            for Property, Value in Item.Properties do
                if type(Value) == "string" and Value == Theme then
                    Item.Item[Property] = Color
                end
            end
        end
    end

    Library.IsMouseOverFrame = function(self, Frame)
        Frame = Frame.Instance

        local MousePosition = Vector2New(Mouse.X, Mouse.Y)

        return MousePosition.X >= Frame.AbsolutePosition.X and MousePosition.X <= Frame.AbsolutePosition.X + Frame.AbsoluteSize.X 
        and MousePosition.Y >= Frame.AbsolutePosition.Y and MousePosition.Y <= Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y
    end

    Library.Watermark = function(self, Name)
        local Watermark = { } 

        local Items = { } do 
            Items["Watermark"] = Instances:Create("Frame", {
                Parent = Library.Holder.Instance,
                Size = UDim2New(0, 0, 0, 20),
                Name = "\0",
                Position = UDim2New(0, 15, 0, 15),
                BorderColor3 = FromRGB(10, 10, 10),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.X,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["Watermark"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})

            Items["Watermark"]:MakeDraggable()
            
            Instances:Create("UIStroke", {
                Parent = Items["Watermark"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Instances:Create("UIPadding", {
                Parent = Items["Watermark"].Instance,
                PaddingTop = UDimNew(0, 2),
                PaddingRight = UDimNew(0, 5),
                PaddingLeft = UDimNew(0, 5)
            }) 
            
            Items["Title"] = Instances:Create("TextLabel", {
                Parent = Items["Watermark"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Name,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 15),
                BackgroundTransparency = 1,
                Position = UDim2New(0, 0, 0, 1),
                BorderSizePixel = 0,
                AutomaticSize = Enum.AutomaticSize.X,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Title"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Title"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["Watermark"].Instance,
                Name = "\0",
                Position = UDim2New(0, -5, 0, -2),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 10, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            })             
        end

        function Watermark:SetVisibility(Bool)
            Items["Watermark"].Instance.Visible = Bool
        end
        
        return Watermark
    end

    Library.Notification = function(self, Text, Duration, Color, Icon)
        local Items = { } do
            Items["Notification"] = Instances:Create("Frame", {
                Parent = Library.NotifHolder.Instance,
                Name = "\0",
                Size = UDim2New(0, 0, 0, 22),
                BorderColor3 = FromRGB(10, 10, 10),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.X,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["Notification"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Notification"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"}) 
            
            Instances:Create("UIPadding", {
                Parent = Items["Notification"].Instance,
                PaddingTop = UDimNew(0, 1),
                PaddingRight = UDimNew(0, 8),
                PaddingLeft = UDimNew(0, 5)
            }) 
            
            Items["Title"] = Instances:Create("TextLabel", {
                Parent = Items["Notification"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Text,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 15),
                BackgroundTransparency = 1,
                Position = UDim2New(0, 13, 0, 2),
                BorderSizePixel = 0,
                AutomaticSize = Enum.AutomaticSize.X,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Title"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Title"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["Notification"].Instance,
                Name = "\0",
                Position = UDim2New(0, -5, 0, -1),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 13, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = Color
            })  
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            })
            
            Items["Icon"] = Instances:Create("ImageLabel", {
                Parent = Items["Notification"].Instance,
                ImageColor3 = FromRGB(255, 255, 255),
                ScaleType = Enum.ScaleType.Fit,
                BorderColor3 = FromRGB(0, 0, 0),
                Name = "\0",
                Image = "rbxassetid://94324346713012",
                BackgroundTransparency = 1,
                Position = UDim2New(0, -2, 0, 3),
                Size = UDim2New(0, 13, 0, 13),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 

            if not Icon then 
                Items["Icon"]:Clean()
                Items["Title"].Instance.Position = UDim2New(0, 1, 0, 2)
            else
                Items["Icon"].Instance.Image = Icon[1]
                Items["Icon"].Instance.ImageColor3 = Icon[2] or FromRGB(255, 255, 255)
            end
        end

        Items["Notification"].Instance.BackgroundTransparency = 1
        Items["Notification"].Instance.Size = UDim2New(0, 0, 0, 0)
        for Index, Value in Items["Notification"].Instance:GetDescendants() do
            if Value:IsA("UIStroke") then 
                Value.Transparency = 1
            elseif Value:IsA("TextLabel") then 
                Value.TextTransparency = 1
            elseif Value:IsA("ImageLabel") then 
                Value.ImageTransparency = 1
            elseif Value:IsA("Frame") then 
                Value.BackgroundTransparency = 1
            end
        end

        Library:Thread(function()
            Items["Notification"]:Tween(nil, {BackgroundTransparency = 0, Size = UDim2New(0, 0, 0, 22)})
            
            task.wait(0.06)

            for Index, Value in Items["Notification"].Instance:GetDescendants() do
                if Value:IsA("UIStroke") then
                    Tween:Create(Value, nil, {Transparency = 0}, true)
                elseif Value:IsA("TextLabel") then
                    Tween:Create(Value, nil, {TextTransparency = 0}, true)
                elseif Value:IsA("ImageLabel") then
                    Tween:Create(Value, nil, {ImageTransparency = 0}, true)
                elseif Value:IsA("Frame") then
                    Tween:Create(Value, nil, {BackgroundTransparency = 0}, true)
                end
            end

            task.delay(Duration + 0.1, function()
                for Index, Value in Items["Notification"].Instance:GetDescendants() do
                    if Value:IsA("UIStroke") then
                        Tween:Create(Value, nil, {Transparency = 1}, true)
                    elseif Value:IsA("TextLabel") then
                        Tween:Create(Value, nil, {TextTransparency = 1}, true)
                    elseif Value:IsA("ImageLabel") then
                        Tween:Create(Value, nil, {ImageTransparency = 1}, true)
                    elseif Value:IsA("Frame") then
                        Tween:Create(Value, nil, {BackgroundTransparency = 1}, true)
                    end
                end

                task.wait(0.06)

                Items["Notification"]:Tween(nil, {BackgroundTransparency = 1, Size = UDim2New(0, 0, 0, 0)})

                task.wait(0.5)
                Items["Notification"]:Clean()
            end)
        end)
    end

    Library.KeybindList = function(self)
        local KeybindList = { }
        self.KeyList = KeybindList

        local Items = { } do
            Items["KeybindList"] = Instances:Create("Frame", {
                Parent = Library.Holder.Instance,
                BorderColor3 = FromRGB(10, 10, 10),
                AnchorPoint = Vector2New(0, 0.5),
                Name = "\0",
                Position = UDim2New(0, 15, 0.5, 0),
                Size = UDim2New(0, 0, 0, 18),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.XY,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["KeybindList"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})

            Items["KeybindList"]:MakeDraggable()
            
            Instances:Create("UIStroke", {
                Parent = Items["KeybindList"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["KeybindList"].Instance,
                Name = "\0",
                Position = UDim2New(0, -5, 0, -5),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 10, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            }) 
            
            Instances:Create("UIPadding", {
                Parent = Items["KeybindList"].Instance,
                PaddingTop = UDimNew(0, 5),
                PaddingBottom = UDimNew(0, 5),
                PaddingRight = UDimNew(0, 5),
                PaddingLeft = UDimNew(0, 5)
            }) 
            
            Items["Title"] = Instances:Create("TextLabel", {
                Parent = Items["KeybindList"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "Keybinds",
                Name = "\0",
                Size = UDim2New(0, 100, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2New(0, 0, 0, -1),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Title"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Title"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Content"] = Instances:Create("Frame", {
                Parent = Items["KeybindList"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 5, 0, 19),
                BorderColor3 = FromRGB(0, 0, 0),
                BorderSizePixel = 0,
                AutomaticSize = Enum.AutomaticSize.XY,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIListLayout", {
                Parent = Items["Content"].Instance,
                Padding = UDimNew(0, 4),
                SortOrder = Enum.SortOrder.LayoutOrder
            }) 
        end

        function KeybindList:Add(Mode, Name, Key)
            local NewKey = Instances:Create("TextLabel", {
                Parent = Items["Content"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "(" .. Mode .. ") " .. Name .. " - " .. Key,
                Name = "\0",
                Size = UDim2New(0, 0, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                BorderSizePixel = 0,
                AutomaticSize = Enum.AutomaticSize.X,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  NewKey:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = NewKey.Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
        
            function NewKey:Set(Mode, Name, Key)
                NewKey.Instance.Text = "(" .. Mode .. ") " .. Name .. " - " .. Key
            end

            function NewKey:SetStatus(Status)
                if Status == "Active" then 
                    NewKey:Tween(nil, {TextColor3 = Library.Theme.Accent})
                    NewKey:ChangeItemTheme({TextColor3 = "Accent"})
                else 
                    NewKey:Tween(nil, {TextColor3 = Library.Theme.Text})
                    NewKey:ChangeItemTheme({TextColor3 = "Text"})
                end
            end

            return NewKey
        end

        function KeybindList:SetVisibility(Bool)
            Items["KeybindList"].Instance.Visible = Bool
        end

        return KeybindList
    end

    Library.CreateColorpicker = function(self, Data)
        local Colorpicker = {
            Hue = 0,
            Saturation = 0,
            Value = 0,

            Alpha = 0,

            HexValue = "",
            
            IsOpen = false,

            Color = FromRGB(0, 0, 0),

            Class = "Colorpicker"
        }

        Library.Flags[Data.Flag] = { }

        local Items = { } do
            Items["ColorpickerButton"] = Instances:Create("TextButton", {
                Parent = Data.Parent.Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                AnchorPoint = Vector2New(1, 0.5),
                Name = "\0",
                Position = UDim2New(1, 0, 0.5, 0),
                Size = UDim2New(0, 20, 0, 10),
                BorderSizePixel = 0,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 0, 0)
            }) 


            Colorpicker.CalculateCount = function(self, Index, YScale, YOffset)
                local MaxButtonsAdded = 5

                local Column = Index % MaxButtonsAdded
            
                local ButtonSize = Items["ColorpickerButton"].Instance.AbsoluteSize
                local Spacing = 4
            
                local XPosition = (ButtonSize.X + Spacing) * Column - Spacing - 21
            
                Items["ColorpickerButton"].Instance.Position = UDim2New(1, -XPosition, YScale or 0.5, YOffset or 0)
            end

            Colorpicker:CalculateCount(Data.Count)
            
            Instances:Create("UIStroke", {
                Parent = Items["ColorpickerButton"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Instances:Create("UIGradient", {
                Parent = Items["ColorpickerButton"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            })             

            Items["ColorpickerWindow"] = Instances:Create("TextButton", {
                Parent = Library.Holder.Instance,
                AutoButtonColor = false,
                Text = "",
                Name = "\0",
                Position = UDim2New(0, Data.Parent.Instance.AbsolutePosition.X, 0, Data.Parent.Instance.AbsolutePosition.Y + 15),
                BorderColor3 = FromRGB(10, 10, 10),
                Visible = false,
                Size = UDim2New(0, 238, 0, 224),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["ColorpickerWindow"]:AddToTheme({BackgroundColor3 = "Background"})
            
            Items["ColorpickerWindow"]:MakeDraggable()
            Items["ColorpickerWindow"]:MakeResizeable(Vector2New(200, 180), Vector2New(9999, 9999))

            Instances:Create("UIStroke", {
                Parent = Items["ColorpickerWindow"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Title"] = Instances:Create("TextLabel", {
                Parent = Items["ColorpickerWindow"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Data.Name,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2New(0, -2, 0, -3),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Title"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Title"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["ColorpickerWindow"].Instance,
                Name = "\0",
                Position = UDim2New(0, -6, 0, -6),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 12, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            }) 
            
            Instances:Create("UIPadding", {
                Parent = Items["ColorpickerWindow"].Instance,
                PaddingTop = UDimNew(0, 6),
                PaddingBottom = UDimNew(0, 6),
                PaddingRight = UDimNew(0, 6),
                PaddingLeft = UDimNew(0, 6)
            }) 
            
            Items["Palette"] = Instances:Create("TextButton", {
                Parent = Items["ColorpickerWindow"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                Name = "\0",
                Position = UDim2New(0, 0, 0, 15),
                Size = UDim2New(1, -26, 1, -40),
                BorderSizePixel = 0,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 0, 0)
            }) 
            
            Items["Saturation"] = Instances:Create("ImageLabel", {
                Parent = Items["Palette"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                Image = Library:GetImage("Saturation"),
                BackgroundTransparency = 1,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Value"] = Instances:Create("ImageLabel", {
                Parent = Items["Palette"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                Image = Library:GetImage("Value"),
                BackgroundTransparency = 1,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["Palette"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["PaletteDragger"] = Instances:Create("Frame", {
                Parent = Items["Palette"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(0, 2, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["PaletteDragger"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Hue"] = Instances:Create("ImageButton", {
                Parent = Items["ColorpickerWindow"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                AutoButtonColor = false,
                AnchorPoint = Vector2New(1, 0),
                Image = Library:GetImage("Hue"),
                Name = "\0",
                Position = UDim2New(1, 0, 0, 15),
                Size = UDim2New(0, 18, 1, -15),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["HueDragger"] = Instances:Create("Frame", {
                Parent = Items["Hue"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 1),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["HueDragger"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Hue"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Alpha"] = Instances:Create("TextButton", {
                Parent = Items["ColorpickerWindow"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                Size = UDim2New(1, -26, 0, 18),
                BorderSizePixel = 0,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 0, 0)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["Alpha"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Checkers"] = Instances:Create("ImageLabel", {
                Parent = Items["Alpha"].Instance,
                ScaleType = Enum.ScaleType.Tile,
                BorderColor3 = FromRGB(0, 0, 0),
                Image = Library:GetImage("Checkers"),
                TileSize = UDim2New(0, 6, 0, 6),
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIGradient", {
                Parent = Items["Checkers"].Instance,
                Transparency = NumSequence{NumSequenceKeypoint(0, 1), NumSequenceKeypoint(1, 0)}
            }) 
            
            Instances:Create("UIGradient", {
                Parent = Items["Alpha"].Instance,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(0, 0, 0))}
            }) 
            
            Items["AlphaDragger"] = Instances:Create("Frame", {
                Parent = Items["Alpha"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(0, 1, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["AlphaDragger"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
        end

        local SlidingPalette = false
        local SlidingHue = false
        local SlidingAlpha = false

        local Debounce = false

        function Colorpicker:SetOpen(Bool)
            if Debounce then 
                return 
            end

            Colorpicker.IsOpen = Bool

            Debounce = true 

            if Bool then 
                Items["ColorpickerWindow"].Instance.Visible = true
                Items["ColorpickerWindow"].Instance.Position = UDim2New(0, Data.Parent.Instance.AbsolutePosition.X, 0, Data.Parent.Instance.AbsolutePosition.Y + 15)

                if Library.CurrentColorpicker then
                    Library.CurrentColorpicker:SetOpen(false)
                    Library.CurrentColorpicker = nil 
                end

                if not Library.CurrentColorpicker then 
                    Library.CurrentColorpicker = Colorpicker
                end
            else
                Library.CurrentColorpicker = nil
            end

            local Descendants = Items["ColorpickerWindow"].Instance:GetDescendants()
            TableInsert(Descendants, Items["ColorpickerWindow"].Instance)

            local NewTween
            for Index, Value in Descendants do 
                local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                if not ValueIndex then 
                    continue
                end

                if not StringFind(Value.ClassName, "UI") then 
                    Value.ZIndex = Bool and 10001 or 1
                end

                if type(ValueIndex) == "table" then
                    for _, Property in ValueIndex do 
                        NewTween = Library:FadeItem(Value, Property, Bool, Data.FadeSpeed)
                    end
                else
                    NewTween = Library:FadeItem(Value, ValueIndex, Bool, Data.FadeSpeed)
                end
            end

            Library:Connect(NewTween.Tween.Completed, function()
                Debounce = false
                Items["ColorpickerWindow"].Instance.Visible = Bool
            end)
        end

        function Colorpicker:Get()
            return Colorpicker.Value
        end

        function Colorpicker:SetVisibility(Bool)
           Data.Parent.Instance.Visible = Bool 
        end

        function Colorpicker:Set(Color, Alpha)
            if type(Color) == "table" then 
                Color = FromRGB(Color[1], Color[2], Color[3])
                Alpha = Color[4]
            elseif type(Color) == "string" then 
                Color = FromHex(Color)
            end

            self.Hue, self.Saturation, self.Value = Color:ToHSV()
            self.Alpha = Alpha or 0

            self.Color = FromHSV(self.Hue, self.Saturation, self.Value)
            self.HexValue = self.Color:ToHex()

            Library.Flags[Data.Flag] = {
                Color = self.Color,
                HexValue =  self.HexValue,
                Alpha = self.Alpha
            }

            local ColorPositionX = MathClamp(1 - self.Saturation, 0, 0.989)
            local ColorPositionY = MathClamp(1 - self.Value, 0, 0.989)

            Items["PaletteDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(ColorPositionX, 0, ColorPositionY, 0)})

            local HuePositionY = MathClamp(self.Hue, 0, 0.994)

            Items["HueDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(0, 0, HuePositionY, 0)})

            local AlphaPositionX = MathClamp(self.Alpha, 0, 0.994)

            Items["AlphaDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(AlphaPositionX, 0, 0, 0)})

            self:Update()
        end

        function Colorpicker:Update(IsFromAlpha)
            self.Color = FromHSV(self.Hue, self.Saturation, self.Value)
            self.HexValue = self.Color:ToHex()

            Library.Flags[Data.Flag] = {
                Color = self.Color,
                HexValue =  self.HexValue,
                Alpha = self.Alpha
            }

            Items["ColorpickerButton"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = self.Color})
            Items["Palette"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = FromHSV(self.Hue, 1, 1)})

            if not IsFromAlpha then 
                Items["Alpha"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = self.Color})
            end

            if Data.Callback then 
                Library:SafeCall(Data.Callback, self.Color, self.Alpha)
            end
        end

        function Colorpicker:SlidePalette(Input)
            if not Input or not SlidingPalette then 
                return
            end

            local ValueX = MathClamp(1 - (Input.Position.X - Items["Palette"].Instance.AbsolutePosition.X) / Items["Palette"].Instance.AbsoluteSize.X, 0, 1)
            local ValueY = MathClamp(1 - (Input.Position.Y - Items["Palette"].Instance.AbsolutePosition.Y) / Items["Palette"].Instance.AbsoluteSize.Y, 0, 1)

            self.Saturation = ValueX
            self.Value = ValueY

            local SlideX = MathClamp((Input.Position.X - Items["Palette"].Instance.AbsolutePosition.X) / Items["Palette"].Instance.AbsoluteSize.X, 0, 0.989)
            local SlideY = MathClamp((Input.Position.Y - Items["Palette"].Instance.AbsolutePosition.Y) / Items["Palette"].Instance.AbsoluteSize.Y, 0, 0.989)

            Items["PaletteDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(SlideX, 0, SlideY, 0)})
            self:Update()            
        end

        function Colorpicker:SlideHue(Input)
            if not Input or not SlidingHue then 
                return
            end

            local ValueY = MathClamp((Input.Position.Y - Items["Hue"].Instance.AbsolutePosition.Y) / Items["Hue"].Instance.AbsoluteSize.Y, 0, 1)

            self.Hue = ValueY

            local PositionY = MathClamp((Input.Position.Y - Items["Hue"].Instance.AbsolutePosition.Y) / Items["Hue"].Instance.AbsoluteSize.Y, 0, 0.994)

            Items["HueDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(0, 0, PositionY, 0)})
            self:Update()
        end

        function Colorpicker:SlideAlpha(Input)
            if not Input or not SlidingAlpha then 
                return
            end

            local ValueX = MathClamp((Input.Position.X - Items["Alpha"].Instance.AbsolutePosition.X) / Items["Alpha"].Instance.AbsoluteSize.X, 0, 1)
            
            self.Alpha = ValueX

            local PositionX = MathClamp((Input.Position.X - Items["Alpha"].Instance.AbsolutePosition.X) / Items["Alpha"].Instance.AbsoluteSize.X, 0, 0.994)

            Items["AlphaDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(PositionX, 0, 0, 0)})
            self:Update(true)
        end

        Items["ColorpickerButton"]:Connect("MouseButton1Down", function()
            Colorpicker:SetOpen(not Colorpicker.IsOpen)
        end)

        Items["Palette"]:Connect("InputBegan", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingPalette = true
                Colorpicker:SlidePalette(Input)
            end
        end)

        Items["Palette"]:Connect("InputEnded", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingPalette = false
            end
        end)

        Items["Hue"]:Connect("InputBegan", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingHue = true
                Colorpicker:SlideHue(Input)
            end
        end)

        Items["Hue"]:Connect("InputEnded", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingHue = false
            end
        end)

        Items["Alpha"]:Connect("InputBegan", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingAlpha = true
                Colorpicker:SlideAlpha(Input)
            end
        end)

        Items["Alpha"]:Connect("InputEnded", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                SlidingAlpha = false
            end
        end)

        Library:Connect(UserInputService.InputChanged, function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseMovement then
                if SlidingPalette then
                    Colorpicker:SlidePalette(Input)
                end

                if SlidingHue then
                    Colorpicker:SlideHue(Input)
                end

                if SlidingAlpha then
                    Colorpicker:SlideAlpha(Input)
                end
            end
        end)

        Library:Connect(UserInputService.InputBegan, function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if Library:IsMouseOverFrame(Items["ColorpickerWindow"]) then
                    return
                end

                Colorpicker:SetOpen(false)
            end
        end)

        if Data.Default then 
            Colorpicker:Set(Data.Default, Data.Alpha)
        end

        Library.SetFlags[Data.Flag] = function(Color, Alpha)
            Colorpicker:Set(Color, Alpha)
        end

        return Colorpicker
    end

    Library.CreateKeybind = function(self, Data)
        local Keybind = {
            Key = nil,
            Value = "",
            Mode = "",

            Toggled = false,
            IsOpen = false,

            Picking = false,

            Class = "Keybind"
        }

        Library.Flags[Data.Flag] = { }

        local KeyListItem

        local Items = { } do 
            Items["KeyButton"] = Instances:Create("TextButton", {
                Parent = Data.Parent.Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(27, 27, 32),
                Text = "",
                AutoButtonColor = false,
                AnchorPoint = Vector2New(1, 0),
                Size = UDim2New(0, 0, 1, 1),
                Name = "\0",
                Position = UDim2New(1, 0, 0, 0),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.X,
                TextSize = 14,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["KeyButton"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Outline"})

            if Library.KeyList then 
                KeyListItem = Library.KeyList:Add(Keybind.Mode, Data.Name, Keybind.Value)
            end
            
            Instances:Create("UIStroke", {
                Parent = Items["KeyButton"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(10, 10, 10)
            }):AddToTheme({Color = "Border"})
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["KeyButton"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "MB2",
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 1, 0, 0),
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Instances:Create("UIPadding", {
                Parent = Items["KeyButton"].Instance,
                PaddingRight = UDimNew(0, 3),
                PaddingLeft = UDimNew(0, 3),
                PaddingBottom = UDimNew(0, 2)
            })             

            Items["Window"] = Instances:Create("Frame", {
                Parent = Data.Parent.Instance,
                BorderColor3 = FromRGB(10, 10, 10),
                AnchorPoint = Vector2New(1, 0),
                Name = "\0",
                Position = UDim2New(1, 0, 1, 5),
                Size = UDim2New(0, 50, 0, 48),
                BorderSizePixel = 2,
                Visible = false,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["Window"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Window"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Toggle"] = Instances:Create("TextButton", {
                Parent = Items["Window"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(235, 157, 255),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "Toggle",
                AutoButtonColor = false,
                Name = "\0",
                BorderSizePixel = 0,
                BackgroundTransparency = 1,
                Position = UDim2New(0, 1, 0, 0),
                Size = UDim2New(1, 0, 0, 15),
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Toggle"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Toggle"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Hold"] = Instances:Create("TextButton", {
                Parent = Items["Window"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "Hold",
                AutoButtonColor = false,
                Name = "\0",
                BorderSizePixel = 0,
                BackgroundTransparency = 1,
                Position = UDim2New(0, 1, 0, 15),
                Size = UDim2New(1, 0, 0, 15),
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Hold"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Hold"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Always"] = Instances:Create("TextButton", {
                Parent = Items["Window"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "Always",
                AutoButtonColor = false,
                Name = "\0",
                BorderSizePixel = 0,
                BackgroundTransparency = 1,
                Position = UDim2New(0, 1, 0, 30),
                Size = UDim2New(1, 0, 0, 15),
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Always"]:AddToTheme({TextColor3 = "Text"})
             
            Instances:Create("UIStroke", {
                Parent = Items["Always"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
        end

        local Modes = {
            ["Toggle"] = Items["Toggle"],
            ["Hold"] = Items["Hold"],
            ["Always"] = Items["Always"]
        }

        local Update = function()
            if KeyListItem then
                KeyListItem:Set(Keybind.Mode, Data.Name, Keybind.Value)
                KeyListItem:SetStatus(Keybind.Toggled and "Active" or "Inactive")
            end
        end

        function Keybind:Get()
           return Keybind.Toggled, Keybind.Key, Keybind.Mode 
        end

        function Keybind:SetVisibility(Bool)
            Data.Parent.Instance.Visible = Bool
        end

        local Debounce = false

        function Keybind:SetOpen(Bool)
            Keybind.IsOpen = Bool

            if Bool then 
                Debounce = true
                Items["Window"].Instance.Visible = true
                Items["Window"].Instance.ZIndex = 16
                Items["Window"]:Tween(nil, {BackgroundTransparency = 0})

                task.wait(0.1)

                for Index, Value in Items["Window"].Instance:GetDescendants() do 
                    if Value:IsA("UIStroke") then
                        Tween:Create(Value, nil, {Transparency = 0}, true)
                    elseif Value:IsA("TextButton") then
                        Tween:Create(Value, nil, {TextTransparency = 0}, true)
                        Value.ZIndex = 16
                    end
                end
            else 
                for Index, Value in Items["Window"].Instance:GetDescendants() do 
                    if Value:IsA("UIStroke") then
                        Tween:Create(Value, nil, {Transparency = 1}, true)
                    elseif Value:IsA("TextButton") then
                        Tween:Create(Value, nil, {TextTransparency = 1}, true)
                        Value.ZIndex = 1
                    end
                end

                task.wait(0.1)

                Items["Window"]:Tween(nil, {BackgroundTransparency = 1})
                Items["Window"].Instance.ZIndex = 1
                task.wait(0.1)
                Items["Window"].Instance.Visible = false
            end

            Debounce = false
        end

        function Keybind:Set(Key)
            if StringFind(tostring(Key), "Enum") then 
                Keybind.Key = tostring(Key)

                Key = Key.Name == "Backspace" and "None" or Key.Name

                local KeyString = Keys[Keybind.Key] or StringGSub(Key, "Enum.", "") or "None"
                local TextToDisplay = StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "") or "None"

                Keybind.Value = TextToDisplay
                Items["Text"].Instance.Text = TextToDisplay
    
                if Data.Callback then 
                    Library:SafeCall(Data.Callback, Keybind.Toggled)
                end
           elseif TableFind({"Toggle", "Hold", "Always"}, Key) then 
                Keybind.Mode = Key
                
                Keybind:SetMode(Key)

                if Data.Callback then 
                    Library:SafeCall(Data.Callback, Keybind.Toggled)
                end
            elseif type(Key) == "table" then 
                local RealKey = Key.Key == "Backspace" and "None" or Key.Key
                Keybind.Key = tostring(Key.Key)

                if Key.Mode then
                    Keybind.Mode = Key.Mode
                    Keybind:SetMode(Key.Mode)
                else
                    Keybind.Mode = "Toggle"
                    Keybind:SetMode("Toggle")
                end

                local KeyString = Keys[Keybind.Key] or StringGSub(tostring(RealKey), "Enum.", "") or RealKey
                local TextToDisplay = KeyString and StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "") or "None"

                TextToDisplay = StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "")

                Keybind.Value = TextToDisplay
                Items["Text"].Instance.Text = TextToDisplay

                if Keybind.Callback then 
                    Library:SafeCall(Keybind.Callback, Keybind.Toggled)
                end
            end

            Keybind.Picking = false
            Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text})
            Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
            Items["Text"].Instance.Size = UDim2New(0, Items["Text"].Instance.TextBounds.X, 1, 1)
            Update()
        end

        function Keybind:SetMode(Mode)
            for Index, Value in Modes do 
                if Index == Mode then 
                    Value:Tween(nil, {TextColor3 = Library.Theme.Accent})
                    Value:ChangeItemTheme({TextColor3 = "Accent"})
                else
                    Value:Tween(nil, {TextColor3 = Library.Theme.Text})
                    Value:ChangeItemTheme({TextColor3 = "Text"})
                end
            end

            if Keybind.Mode == "Always" then 
                Keybind.Toggled = true
            else
                Keybind.Toggled = false
            end

            Library.Flags[Data.Flag] = {
                Mode = Keybind.Mode,
                Key = Keybind.Key,
                Toggled = Keybind.Toggled
            }

            if Data.Callback then 
                Library:SafeCall(Data.Callback, Keybind.Toggled)
            end

            Update()
        end

        function Keybind:Press(Bool)
            if Keybind.Mode == "Toggle" then
                Keybind.Toggled = not Keybind.Toggled
            elseif Keybind.Mode == "Hold" then
                Keybind.Toggled = Bool
            elseif Keybind.Mode == "Always" then
                Keybind.Toggled = true
            end

            Library.Flags[Data.Flag] = {
                Mode = Keybind.Mode,
                Key = Keybind.Key,
                Toggled = Keybind.Toggled
            }

            if Data.Callback then 
                Library:SafeCall(Data.Callback, Keybind.Toggled)
            end

            Update()
        end

        Items["KeyButton"]:Connect("MouseButton1Click", function()
            if Keybind.Picking then 
                return
            end

            Keybind.Picking = true

            Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
            Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})

            local InputBegan 
            InputBegan = UserInputService.InputBegan:Connect(function(Input)
                if Input.UserInputType == Enum.UserInputType.Keyboard then 
                    Keybind:Set(Input.KeyCode)
                else
                    Keybind:Set(Input.UserInputType)
                end

                InputBegan:Disconnect()
                InputBegan = nil
            end)
        end)

        Items["KeyButton"]:Connect("MouseButton2Down", function()
            Keybind:SetOpen(not Keybind.IsOpen)
        end)

        Library:Connect(UserInputService.InputBegan, function(Input)
            if tostring(Input.KeyCode) == Keybind.Key or tostring(Input.UserInputType) == Keybind.Key then
                if Keybind.Mode == "Toggle" then 
                    Keybind:Press()
                elseif Keybind.Mode == "Hold" then 
                    Keybind:Press(true)
                end
            end

            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                if Library:IsMouseOverFrame(Items["Window"]) then
                    return
                end

                if Debounce then 
                    return
                end

                Keybind:SetOpen(false)
            end
        end)

        Library:Connect(UserInputService.InputEnded, function(Input)
            if tostring(Input.KeyCode) == Keybind.Key or tostring(Input.UserInputType) == Keybind.Key then
                if Keybind.Mode == "Hold" then 
                    Keybind:Press(false)
                end
            end
        end)

        Items["Toggle"]:Connect("MouseButton1Down", function()
            Keybind.Mode = "Toggle"
            Keybind:SetMode("Toggle")
        end)

        Items["Always"]:Connect("MouseButton1Down", function()
            Keybind.Mode = "Always"
            Keybind:SetMode("Always")
        end)

        Items["Hold"]:Connect("MouseButton1Down", function()
            Keybind.Mode = "Hold"
            Keybind:SetMode("Hold")
        end)

        if Data.Default then 
            Keybind:Set({
                Key = Data.Default,
                Mode = Data.Mode or "Toggle"
            })
        end

        Library.SetFlags[Data.Flag] = function(Value)
            Keybind:Set(Value)
        end

        return Keybind
    end

    Library.Window = function(self, Data)
        Data = Data or { }

        local Window = {
            Name = Data.Name or Data.name or "Window",
            Size = Data.Size or Data.size or UDim2New(0, 500, 0, 600),

            FadeSpeed = Data.FadeSpeed or Data.fadespeed or 0.25,

            Pages = { },
            SubPages = { },
            Elements = { },

            IsOpen = true
        }

        local Items = { } do 
            Items["MainFrame"] = Instances:Create("Frame", {
                Parent = Library.Holder.Instance,
                AnchorPoint = Vector2New(0, 0),
                Name = "\0",
                Position = UDim2New(0, 0, 0, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = Window.Size,
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["MainFrame"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})

            Items["MainFrame"].Instance.Position = UDim2New(0, Camera.ViewportSize.X / 4, 0, Camera.ViewportSize.Y / 4)

            Items["MainFrame"]:MakeDraggable()
            Items["MainFrame"]:MakeResizeable(Vector2New(Window.Size.X.Offset, Window.Size.Y.Offset), Vector2New(9999, 9999))
            
            Items["AccentBorder"] = Instances:Create("UIStroke", {
                Parent = Items["MainFrame"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(235, 157, 255)
            })  Items["AccentBorder"]:AddToTheme({Color = "Accent"})
            
            Items["Title"] = Instances:Create("TextLabel", {
                Parent = Items["MainFrame"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Window.Name,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2New(0, 6, 0, 1),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Title"]:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = Items["Title"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Inline"] = Instances:Create("Frame", {
                Parent = Items["MainFrame"].Instance,
                Name = "\0",
                Position = UDim2New(0, 7, 0, 20),
                BorderColor3 = FromRGB(27, 27, 32),
                Size = UDim2New(1, -14, 1, -27),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["Inline"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Outline"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Inline"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = Library.Theme.Border,
                Name = "\0"
            }):AddToTheme({Color = "Border"})
            
            Items["Pages"] = Instances:Create("Frame", {
                Parent = Items["Inline"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 7, 0, 7),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -14, 0, 19),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })
            
            Instances:Create("UIListLayout", {
                Parent = Items["Pages"].Instance,
                FillDirection = Enum.FillDirection.Horizontal,
                HorizontalFlex = Enum.UIFlexAlignment.Fill,
                Padding = UDimNew(0, 6),
                SortOrder = Enum.SortOrder.LayoutOrder
            })

            Items["Content"] = Instances:Create("Frame", {
                Parent = Items["Inline"].Instance,
                Name = "\0",
                Position = UDim2New(0, 7, 0, 26),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(1, -14, 1, -33),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["Content"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
        
            Instances:Create("UIStroke", {
                Parent = Items["Content"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = Library.Theme.Outline,
                Name = "\0"
            }):AddToTheme({Color = "Outline"})
        end

        local Debounce = false

        function Window:SetOpen(Bool)
            if Debounce then 
                return 
            end

            Window.IsOpen = Bool

            Debounce = true 

            if Bool then 
                Items["MainFrame"].Instance.Visible = true
            end

            local Descendants = Items["MainFrame"].Instance:GetDescendants()
            TableInsert(Descendants, Items["MainFrame"].Instance)

            local NewTween
            for Index, Value in Descendants do 
                local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                if not ValueIndex then 
                    continue
                end

                if type(ValueIndex) == "table" then
                    for _, Property in ValueIndex do 
                        NewTween = Library:FadeItem(Value, Property, Bool, Window.FadeSpeed)
                    end
                else
                    NewTween = Library:FadeItem(Value, ValueIndex, Bool, Window.FadeSpeed)
                end
            end

            Library:Connect(NewTween.Tween.Completed, function()
                Debounce = false
                Items["MainFrame"].Instance.Visible = Bool
            end)
        end

        Library:Connect(UserInputService.InputBegan, function(Input)
            if tostring(Input.KeyCode) == Library.MenuKeybind or tostring(Input.UserInputType) == Library.MenuKeybind then
                Window:SetOpen(not Window.IsOpen)
            end
        end)

        Window.Elements = Items

        return setmetatable(Window, Library)
    end

    Library.Page = function(self, Data)
        Data = Data or { }

        local Page = {
            Window = self,

            Name = Data.Name or Data.name or "Page",
            Columns = Data.Columns or Data.columns or 2,

            HasSubtabs = Data.Subtabs or Data.subtabs or false,

            Active = false,
            ColumnsData = { },
            Elements = { }
        }

        local Items = { } do 
            Items["Inactive"] = Instances:Create("TextButton", {
                Parent = Page.Window.Elements["Pages"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Text = "",
                AutoButtonColor = false,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 2,
                TextSize = 14,
                BackgroundColor3 = FromRGB(30, 30, 35)
            })  Items["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})

            Instances:Create("UIStroke", {
                Parent = Items["Inactive"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = Library.Theme.Outline,
                Name = "\0"
            }):AddToTheme({Color = "Outline"})
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Inactive"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                TextTransparency = 0.47999998927116394,
                Text = Page.Name,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BackgroundTransparency = 1,
                Position = UDim2New(0, 0, 0, -1),
                BorderSizePixel = 0,
                BorderColor3 = FromRGB(0, 0, 0),
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Hide"] = Instances:Create("Frame", {
                Parent = Items["Inactive"].Instance,
                Visible = false,
                BorderColor3 = FromRGB(0, 0, 0),
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                Size = UDim2New(1, 0, 0, 3),
                ZIndex = 2,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["Hide"]:AddToTheme({BackgroundColor3 = "Background"})
            
            Items["MiscPixel1"] = Instances:Create("Frame", {
                Parent = Items["Hide"].Instance,
                Size = UDim2New(0, 1, 0, 1),
                Name = "\0",
                Position = UDim2New(0, -1, 0, 1),
                BorderColor3 = FromRGB(0, 0, 0),
                ZIndex = 2,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(27, 27, 32)
            })  Items["MiscPixel1"]:AddToTheme({BackgroundColor3 = "Outline"})
            
            Items["MiscPixel2"] = Instances:Create("Frame", {
                Parent = Items["Hide"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                AnchorPoint = Vector2New(1, 0),
                Name = "\0",
                Position = UDim2New(1, 1, 0, 1),
                Size = UDim2New(0, 1, 0, 1),
                ZIndex = 2,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(27, 27, 32)
            })  Items["MiscPixel2"]:AddToTheme({BackgroundColor3 = "Outline"})
            
            Items["UIGradient"] = Instances:Create("UIGradient", {
                Parent = Items["Inactive"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(108, 108, 108))}
            })            

            Items["Page"] = Instances:Create("Frame", {
                Parent = Page.Window.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255),
                Visible = false
            })
            
            if not Page.HasSubtabs then 
                Instances:Create("UIListLayout", {
                    Parent = Items["Page"].Instance,
                    FillDirection = Enum.FillDirection.Horizontal,
                    HorizontalFlex = Enum.UIFlexAlignment.Fill,
                    SortOrder = Enum.SortOrder.LayoutOrder,
                    VerticalFlex = Enum.UIFlexAlignment.Fill
                })
                
                for Index = 1, Page.Columns do
                    local NewColumn = Instances:Create("ScrollingFrame", {
                        Parent = Items["Page"].Instance,
                        ScrollBarImageColor3 = FromRGB(235, 157, 255),
                        Active = true,
                        AutomaticCanvasSize = Enum.AutomaticSize.Y,
                        ScrollBarThickness = 1,
                        Name = "\0",
                        BackgroundTransparency = 1,
                        Size = UDim2New(0, 100, 0, 100),
                        BackgroundColor3 = FromRGB(255, 255, 255),
                        BorderColor3 = FromRGB(0, 0, 0),
                        BorderSizePixel = 0,
                        BottomImage = Library:GetImage("Scrollbar"),
                        MidImage = Library:GetImage("Scrollbar"),
                        TopImage = Library:GetImage("Scrollbar"),
                        CanvasSize = UDim2New(0, 0, 0, 0)
                    })  NewColumn:AddToTheme({ScrollBarImageColor3 = "Accent"})
                    
                    Instances:Create("UIPadding", {
                        Parent = NewColumn.Instance,
                        PaddingTop = UDimNew(0, 6),
                        PaddingBottom = UDimNew(0, 6),
                        PaddingRight = UDimNew(0, 6),
                        PaddingLeft = UDimNew(0, 6)
                    })
                    
                    Instances:Create("UIListLayout", {
                        Parent = NewColumn.Instance,
                        Padding = UDimNew(0, 8),
                        SortOrder = Enum.SortOrder.LayoutOrder
                    }) 

                    Page.ColumnsData[Index] = NewColumn
                end
            else
                Items["Columns"] = Instances:Create("Frame", {
                    Parent = Items["Page"].Instance,
                    Name = "\0",
                    Position = UDim2New(0, 7, 0, 45),
                    BorderColor3 = FromRGB(10, 10, 10),
                    Size = UDim2New(1, -14, 1, -52),
                    BorderSizePixel = 2,
                    BackgroundColor3 = FromRGB(15, 15, 20)
                })  Items["Columns"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})

                Items["SubTabs"] = Instances:Create("Frame", {
                    Parent = Items["Page"].Instance,
                    Name = "\0",
                    BackgroundTransparency = 1,
                    Position = UDim2New(0, 7, 0, 7),
                    BorderColor3 = FromRGB(0, 0, 0),
                    Size = UDim2New(1, -14, 0, 35),
                    BorderSizePixel = 0,
                    BackgroundColor3 = FromRGB(255, 255, 255)
                }) 

                Instances:Create("UIListLayout", {
                    Parent = Items["SubTabs"].Instance,
                    FillDirection = Enum.FillDirection.Horizontal,
                    HorizontalFlex = Enum.UIFlexAlignment.Fill,
                    Padding = UDimNew(0, 6),
                    SortOrder = Enum.SortOrder.LayoutOrder
                }) 
            end
        end

        local Debounce = false

        function Page:Turn(Bool)
            if Debounce then 
                return 
            end

            Page.Active = Bool

            Debounce = true 

            if Bool then 
                Items["Page"].Instance.Visible = true

                Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
                Items["Hide"].Instance.Visible = true

                Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
            else
                Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.5})
                Items["Hide"].Instance.Visible = false

                Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
            end

            local Descendants = Items["Page"].Instance:GetDescendants()
            TableInsert(Descendants, Items["Page"].Instance)

            local NewTween
            for Index, Value in Descendants do 
                local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                if not ValueIndex then 
                    continue
                end

                if type(ValueIndex) == "table" then
                    for _, Property in ValueIndex do 
                        NewTween = Library:FadeItem(Value, Property, Bool, Page.Window.FadeSpeed or 0.5)
                    end
                else
                    NewTween = Library:FadeItem(Value, ValueIndex, Bool, Page.Window.FadeSpeed or 0.5)
                end
            end

            Library:Connect(NewTween.Tween.Completed, function()
                Debounce = false
                Items["Page"].Instance.Visible = Bool
            end)
        end

        Items["Inactive"]:Connect("MouseButton1Down", function()
            for Index, Value in Page.Window.Pages do
                Value:Turn(Value == Page)
            end
        end)

        if #Page.Window.Pages == 0 then 
            Page:Turn(true)
        end

        Page.Elements = Items

        TableInsert(Page.Window.Pages, Page)
        return setmetatable(Page, Library.Pages)
    end

    Library.Pages.SubPage = function(self, Data)
        Data = Data or { }

        local SubPage = {
            Window = self.Window,
            Page = self,

            Icon = Data.Icon or Data.icon or "9080568477801",
            Columns = Data.Columns or Data.columns or 2,

            Active = false,
            ColumnsData = { },
            Elements = { }
        }

        local Items = { } do
            Items["Inactive"] = Instances:Create("TextButton", {
                Parent = SubPage.Page.Elements["SubTabs"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Text = "",
                AutoButtonColor = false,
                Name = "\0",
                Size = UDim2New(1, 0, 1, -2),
                BorderSizePixel = 2,
                TextSize = 14,
                BackgroundColor3 = FromRGB(30, 30, 35)
            })  Items["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})

            Instances:Create("UIStroke", {
                Parent = Items["Inactive"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})

            Items["Hide"] = Instances:Create("Frame", {
                Parent = Items["Inactive"].Instance,
                Visible = false,
                BorderColor3 = FromRGB(0, 0, 0),
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 2),
                Size = UDim2New(1, 0, 0, 2),
                ZIndex = 5,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["Hide"]:AddToTheme({BackgroundColor3 = "Background"})

            Items["MiscPixel1"] = Instances:Create("Frame", {
                Parent = Items["Hide"].Instance,
                Size = UDim2New(0, 1, 0, 1),
                Name = "\0",
                Position = UDim2New(0, -1, 0, 1),
                BorderColor3 = FromRGB(0, 0, 0),
                ZIndex = 5,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(27, 27, 32)
            }) 

            Items["MiscPixel2"] = Instances:Create("Frame", {
                Parent = Items["Hide"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                AnchorPoint = Vector2New(1, 0),
                Name = "\0",
                Position = UDim2New(1, 1, 0, 1),
                Size = UDim2New(0, 1, 0, 1),
                ZIndex = 5,
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(27, 27, 32)
            }) 

            Items["Icon"] = Instances:Create("ImageLabel", {
                Parent = Items["Inactive"].Instance,
                ScaleType = Enum.ScaleType.Fit,
                ImageTransparency = 0.35,
                BorderColor3 = FromRGB(0, 0, 0),
                Name = "\0",
                AnchorPoint = Vector2New(0.5, 0.5),
                Image = "rbxassetid://"..SubPage.Icon,
                BackgroundTransparency = 1,
                Position = UDim2New(0.5, 0, 0.5, 0),
                Size = UDim2New(0, 30, 0, 30),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Icon"]:AddToTheme({ImageColor3 = "Text"})

            Instances:Create("UIGradient", {
                Parent = Items["Inactive"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(138, 138, 138))}
            }) 

            Items["Subtab"] = Instances:Create("Frame", {
                Parent = SubPage.Page.Elements["Columns"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 

            Instances:Create("UIPadding", {
                Parent = Items["Subtab"].Instance,
                PaddingTop = UDimNew(0, 6),
                PaddingRight = UDimNew(0, 6),
                PaddingLeft = UDimNew(0, 6)
            }) 

            Instances:Create("UIListLayout", {
                Parent = Items["Subtab"].Instance,
                FillDirection = Enum.FillDirection.Horizontal,
                HorizontalFlex = Enum.UIFlexAlignment.Fill,
                SortOrder = Enum.SortOrder.LayoutOrder,
                VerticalFlex = Enum.UIFlexAlignment.Fill
            }) 

            Instances:Create("UIStroke", {
                Parent = Items["Subtab"].Instance,
                Color = FromRGB(27, 27, 32),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Outline"})

            for Index = 1, SubPage.Columns do
                local NewColumn = Instances:Create("ScrollingFrame", {
                    Parent = Items["Subtab"].Instance,
                    ScrollBarImageColor3 = FromRGB(235, 157, 255),
                    Active = true,
                    AutomaticCanvasSize = Enum.AutomaticSize.Y,
                    ScrollBarThickness = 1,
                    Name = "\0",
                    BackgroundTransparency = 1,
                    Size = UDim2New(0, 100, 0, 100),
                    BackgroundColor3 = FromRGB(255, 255, 255),
                    BorderColor3 = FromRGB(0, 0, 0),
                    BorderSizePixel = 0,
                    CanvasSize = UDim2New(0, 0, 0, 0)
                })  NewColumn:AddToTheme({ScrollBarImageColor3 = "Accent"})

                Instances:Create("UIPadding", {
                    Parent = NewColumn.Instance,
                    PaddingTop = UDimNew(0, 6),
                    PaddingBottom = UDimNew(0, 6),
                    PaddingRight = UDimNew(0, 6),
                    PaddingLeft = UDimNew(0, 6)
                }) 

                Instances:Create("UIListLayout", {
                    Parent = NewColumn.Instance,
                    Padding = UDimNew(0, 8),
                    SortOrder = Enum.SortOrder.LayoutOrder
                }) 

                SubPage.ColumnsData[Index] = NewColumn
            end
        end

        local Debounce = false

        function SubPage:Turn(Bool)
            if Debounce then 
                return 
            end

            SubPage.Active = Bool

            Debounce = true 

            if Bool then 
                Items["Subtab"].Instance.Visible = true

                Items["Icon"]:Tween(nil, {ImageColor3 = Library.Theme.Accent, ImageTransparency = 0})
                Items["Hide"].Instance.Visible = true

                Items["Icon"]:ChangeItemTheme({ImageColor3 = "Accent"})

                Items["Inactive"].Instance.Size = UDim2New(1, 0, 1, 1)
            else
                Items["Icon"]:Tween(nil, {ImageColor3 = Library.Theme.Text, ImageTransparency = 0.35})
                Items["Hide"].Instance.Visible = false

                Items["Icon"]:ChangeItemTheme({ImageColor3 = "Text"})
                Items["Inactive"].Instance.Size = UDim2New(1, 0, 1, -2)
            end

            local Descendants = Items["Subtab"].Instance:GetDescendants()
            TableInsert(Descendants, Items["Subtab"].Instance)

            local NewTween
            for Index, Value in Descendants do 
                local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                if not ValueIndex then 
                    continue
                end

                if type(ValueIndex) == "table" then
                    for _, Property in ValueIndex do 
                        NewTween = Library:FadeItem(Value, Property, Bool, SubPage.Window.FadeSpeed or 0.5)
                    end
                else
                    NewTween = Library:FadeItem(Value, ValueIndex, Bool, SubPage.Window.FadeSpeed or 0.5)
                end
            end

            Library:Connect(NewTween.Tween.Completed, function()
                Debounce = false
                Items["Subtab"].Instance.Visible = Bool
            end)
        end

        Items["Inactive"]:Connect("MouseButton1Down", function()
            for Index, Value in SubPage.Window.SubPages do
                Value:Turn(Value == SubPage)
            end
        end)

        if #SubPage.Window.SubPages == 0 then 
            SubPage:Turn(true)
        end

        SubPage.Elements = Items

        TableInsert(SubPage.Window.SubPages, SubPage)
        return setmetatable(SubPage, Library.Pages)
    end

    Library.Pages.Section = function(self, Data)
        Data = Data or { }

        local Section = {
            Window = self.Window,
            Page = self,

            Name = Data.Name or Data.name or "Section",
            Side = Data.Side or Data.side or 1,

            Elements = { }
        }

        local Items = { } do 
            Items["Section"] = Instances:Create("Frame", {
                Parent = Section.Page.ColumnsData[Section.Side].Instance,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 25),
                BorderColor3 = FromRGB(27, 27, 32),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["Section"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Section"].Instance,
                Color = FromRGB(10, 10, 10),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Border"})
            
            Instances:Create("UIPadding", {
                Parent = Items["Section"].Instance,
                PaddingBottom = UDimNew(0, 6)
            })
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["Section"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            })
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Section"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Section.Name,
                Name = "\0",
                Size = UDim2New(1, -12, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2New(0, 4, 0, 2),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Content"] = Instances:Create("Frame", {
                Parent = Items["Section"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 7, 0, 21),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -14, 1, -20),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })
            
            Instances:Create("UIListLayout", {
                Parent = Items["Content"].Instance,
                Padding = UDimNew(0, 6),
                SortOrder = Enum.SortOrder.LayoutOrder
            })
        end

        Section.Elements = Items

        return setmetatable(Section, Library.Sections)
    end

    Library.Pages.MultiSection = function(self, Data)
        local MultiSection = {
            Window = self.Window,
            Page = self,
            
            Sections = Data.Sections or Data.sections or { "Section 1", "Section 2", "Section 3" }, 
            Side = Data.Side or Data.side or 1,

            SectionContents = { },

            Elements = { }
        }

        local Items = { } do
            Items["MultiSection"] = Instances:Create("Frame", {
                Parent = MultiSection.Page.ColumnsData[MultiSection.Side].Instance,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 25),
                BorderColor3 = FromRGB(27, 27, 32),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["MultiSection"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})
            
            Instances:Create("UIStroke", {
                Parent = Items["MultiSection"].Instance,
                Color = FromRGB(10, 10, 10),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Border"})
            
            Instances:Create("UIPadding", {
                Parent = Items["MultiSection"].Instance,
                PaddingBottom = UDimNew(0, 6)
            }) 
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["MultiSection"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            }) 
            
            Items["Sections"] = Instances:Create("Frame", {
                Parent = Items["MultiSection"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 7, 0, 9),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -14, 0, 19),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Instances:Create("UIListLayout", {
                Parent = Items["Sections"].Instance,
                FillDirection = Enum.FillDirection.Horizontal,
                HorizontalFlex = Enum.UIFlexAlignment.Fill,
                Padding = UDimNew(0, 5),
                SortOrder = Enum.SortOrder.LayoutOrder
            }) 

            Items["Content"] = Instances:Create("Frame", {
                Parent = Items["MultiSection"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 7, 0, 35),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(1, -14, 1, -33),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(15, 15, 20)
            }) 
        end

        for Index, Value in MultiSection.Sections do 
            local NewSection = {
                Window = MultiSection.Window,
                Page = MultiSection.Page,
                MultiSection = MultiSection,

                Name = Value,

                Elements = { },

                Active = false,
            }

            local SubItems = { } do 
                SubItems["Inactive"] = Instances:Create("TextButton", {
                    Parent = Items["Sections"].Instance,
                    FontFace = Library.Font,
                    TextColor3 = FromRGB(0, 0, 0),
                    BorderColor3 = FromRGB(10, 10, 10),
                    Text = "",
                    AutoButtonColor = false,
                    Name = "\0",
                    Size = UDim2New(1, 0, 1, 0),
                    BorderSizePixel = 2,
                    TextSize = 14,
                    BackgroundColor3 = FromRGB(30, 30, 35)
                })  SubItems["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})

                SubItems["Text"] = Instances:Create("TextLabel", {
                    Parent = SubItems["Inactive"].Instance,
                    FontFace = Library.Font,
                    TextColor3 = FromRGB(215, 215, 215),
                    TextTransparency = 0.48,
                    Text = NewSection.Name,
                    Name = "\0",
                    Size = UDim2New(1, 0, 1, 0),
                    BackgroundTransparency = 1,
                    Position = UDim2New(0, 0, 0, -1),
                    BorderSizePixel = 0,
                    BorderColor3 = FromRGB(0, 0, 0),
                    TextSize = 12,
                    BackgroundColor3 = FromRGB(255, 255, 255)
                })  SubItems["Text"]:AddToTheme({TextColor3 = "Text"})

                Instances:Create("UIStroke", {
                    Parent = SubItems["Text"].Instance,
                    LineJoinMode = Enum.LineJoinMode.Miter,
                    Name = "\0"
                }):AddToTheme({Color = "Text Border"})

                SubItems["Hide"] = Instances:Create("Frame", {
                    Parent = SubItems["Inactive"].Instance,
                    Visible = false,
                    BorderColor3 = FromRGB(0, 0, 0),
                    AnchorPoint = Vector2New(0, 1),
                    Name = "\0",
                    Position = UDim2New(0, 0, 1, 0),
                    Size = UDim2New(1, 0, 0, 3),
                    ZIndex = 2,
                    BorderSizePixel = 0,
                    BackgroundColor3 = FromRGB(15, 15, 20)
                })  SubItems["Hide"]:AddToTheme({BackgroundColor3 = "Background"})

                SubItems["MiscPixel1"] = Instances:Create("Frame", {
                    Parent = SubItems["Hide"].Instance,
                    Size = UDim2New(0, 1, 0, 1),
                    Name = "\0",
                    Position = UDim2New(0, -1, 0, 1),
                    BorderColor3 = FromRGB(0, 0, 0),
                    ZIndex = 2,
                    BorderSizePixel = 0,
                    BackgroundColor3 = FromRGB(27, 27, 32)
                })  SubItems["MiscPixel1"]:AddToTheme({BackgroundColor3 = "Outline"})

                SubItems["MiscPixel2"] = Instances:Create("Frame", {
                    Parent = SubItems["Hide"].Instance,
                    BorderColor3 = FromRGB(0, 0, 0),
                    AnchorPoint = Vector2New(1, 0),
                    Name = "\0",
                    Position = UDim2New(1, 1, 0, 1),
                    Size = UDim2New(0, 1, 0, 1),
                    ZIndex = 2,
                    BorderSizePixel = 0,
                    BackgroundColor3 = FromRGB(27, 27, 32)
                })  SubItems["MiscPixel2"]:AddToTheme({BackgroundColor3 = "Outline"})

                Instances:Create("UIStroke", {
                    Parent = SubItems["Inactive"].Instance,
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                    LineJoinMode = Enum.LineJoinMode.Miter,
                    Name = "\0",
                    Color = FromRGB(27, 27, 32)
                }):AddToTheme({Color = "Outline"})

                Instances:Create("UIGradient", {
                    Parent = SubItems["Inactive"].Instance,
                    Rotation = 90,
                    Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(108, 108, 108))}
                }) 

                SubItems["Content"] = Instances:Create("Frame", {
                    Parent = Items["Content"].Instance,
                    BackgroundTransparency = 1,
                    Name = "\0",
                    BorderColor3 = FromRGB(0, 0, 0),
                    Size = UDim2New(1, 0, 1, 0),
                    BorderSizePixel = 0,
                    Visible = false,
                    BackgroundColor3 = FromRGB(255, 255, 255)
                }) 
                
                Instances:Create("UIListLayout", {
                    Parent = SubItems["Content"].Instance,
                    Padding = UDimNew(0, 6),
                    SortOrder = Enum.SortOrder.LayoutOrder
                }) 
            end

            local Debounce = false

            function NewSection:Turn(Bool)
                if Debounce then 
                    return 
                end

                NewSection.Active = Bool

                Debounce = true 

                if Bool then 
                    SubItems["Content"].Instance.Visible = true

                    SubItems["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})

                    SubItems["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
                else
                    SubItems["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.5})

                    SubItems["Text"]:ChangeItemTheme({TextColor3 = "Text"})
                end

                local Descendants = SubItems["Content"].Instance:GetDescendants()
                TableInsert(Descendants, SubItems["Content"].Instance)

                local NewTween
                for Index, Value in Descendants do 
                    local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                    if not ValueIndex then 
                        continue
                    end

                    if type(ValueIndex) == "table" then
                        for _, Property in ValueIndex do 
                            NewTween = Library:FadeItem(Value, Property, Bool, MultiSection.Window.FadeSpeed or 0.5)
                        end
                    else
                        NewTween = Library:FadeItem(Value, ValueIndex, Bool, MultiSection.Window.FadeSpeed or 0.5)
                    end
                end

                Library:Connect(NewTween.Tween.Completed, function()
                    Debounce = false
                    SubItems["Content"].Instance.Visible = Bool
                end)
            end

            SubItems["Inactive"]:Connect("MouseButton1Down", function()
                for Index, Value in MultiSection.SectionContents do
                    Value:Turn(Value == NewSection)
                end
            end)

            if #MultiSection.SectionContents == 0 then 
                NewSection:Turn(true)
            end

            NewSection.Elements = SubItems

            MultiSection.SectionContents[#MultiSection.SectionContents+1] = setmetatable(NewSection, Library.Sections)
        end

        MultiSection.SectionContents[1]:Turn(true)
        MultiSection.Window.Sections[#MultiSection.Window.Sections+1] = MultiSection
        return TableUnpack(MultiSection.SectionContents)
    end

    Library.Pages.ScrollableSection = function(self, Data)
        Data = Data or { }

        local Section = {
            Window = self.Window,
            Page = self,

            Name = Data.Name or Data.name or "Section",
            Side = Data.Side or Data.side or 1,
            Size = Data.Size or Data.size or 175,

            Elements = { }
        }

        local Items = { } do 
            Items["Section"] = Instances:Create("Frame", {
                Parent = Section.Page.ColumnsData[Section.Side].Instance,
                Name = "\0",
                Size = UDim2New(1, 0, 0, Section.Size),
                BorderColor3 = FromRGB(27, 27, 32),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["Section"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})

            Items["Fade"] = Instances:Create("Frame", {
                Parent = Items["Section"].Instance,
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 20),
                AnchorPoint = Vector2New(0, 1),
                Position = UDim2New(0, 0, 1, 2),
                BorderSizePixel = 0,
                ZIndex = 15,
                BackgroundColor3 = FromRGB(27, 27, 32)
            })  Items["Fade"]:AddToTheme({BackgroundColor3 = "Inline"})

            Instances:Create("UIGradient", {
                Parent = Items["Fade"].Instance,
                Rotation = -90,
                Transparency = NumSequence{NumSequenceKeypoint(0, 0), NumSequenceKeypoint(0.718, 0.768750011920929), NumSequenceKeypoint(1, 1)}
            })
            
            Instances:Create("UIStroke", {
                Parent = Items["Section"].Instance,
                Color = FromRGB(10, 10, 10),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Border"})
            
            Instances:Create("UIPadding", {
                Parent = Items["Section"].Instance,
                PaddingBottom = UDimNew(0, 6)
            })
            
            Items["AccentLine"] = Instances:Create("Frame", {
                Parent = Items["Section"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 2),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["AccentLine"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
            })
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Section"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Section.Name,
                Name = "\0",
                Size = UDim2New(1, -12, 0, 15),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Position = UDim2New(0, 4, 0, 2),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Content"] = Instances:Create("ScrollingFrame", {
                Parent = Items["Section"].Instance,
                Name = "\0",
                ScrollBarThickness = 3,
                AutomaticCanvasSize = Enum.AutomaticSize.Y,
                CanvasSize = UDim2New(0, 0, 0, 0),
                ScrollBarImageColor3 = FromRGB(235, 157, 255),
                MidImage = Library:GetImage("Scrollbar"),
                TopImage = Library:GetImage("Scrollbar"),
                BottomImage = Library:GetImage("Scrollbar"),
                Active = true,
                BackgroundTransparency = 1,
                Position = UDim2New(0, 0, 0, 21),
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -5, 1, -20),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Content"]:AddToTheme({ScrollBarImageColor3 = "Accent"})

            Instances:Create("UIPadding", {
                Parent = Items["Content"].Instance,
                PaddingTop = UDimNew(0, 0),
                PaddingBottom = UDimNew(0, 8),
                PaddingRight = UDimNew(0, 11),
                PaddingLeft = UDimNew(0, 8)
            })
            
            Instances:Create("UIListLayout", {
                Parent = Items["Content"].Instance,
                Padding = UDimNew(0, 6),
                SortOrder = Enum.SortOrder.LayoutOrder
            })
        end

        Section.Elements = Items

        return setmetatable(Section, Library.Sections)
    end

    Library.Sections.Divider = function(self)
        local Divider = {
            Window = self.Window,
            Page = self.Page,
            Section = self,
        }

        local Items = { } do
            Items["Divider"] = Instances:Create("Frame", {
                Parent = Divider.Section.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 10),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 

            Items["RealDivider"] = Instances:Create("Frame", {
                Parent = Items["Divider"].Instance,
                AnchorPoint = Vector2New(0, 0.5),
                Name = "\0",
                Position = UDim2New(0, 0, 0.5, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(1, 0, 0, 3),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(15, 15, 20)
            })  Items["RealDivider"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})

            Instances:Create("UIStroke", {
                Parent = Items["RealDivider"].Instance,
                Color = FromRGB(27, 27, 32),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Outline"})
        end
        
        function Divider:SetVisibility(Bool)
            Items["Divider"].Instance.Visible = Bool
        end

        return Divider
    end

    Library.Sections.Toggle = function(self, Data)
        Data = Data or { }

        local Toggle = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Name = Data.Name or Data.name or "Toggle",
            Flag = Data.Flag or Data.flag or Library:NextFlag(),
            Default = Data.Default or Data.default or false,
            Callback = Data.Callback or Data.callback or function() end,

            Value = false,
            Class = "Toggle",

            Count = 0
        }

        local Items = { } do 
            Items["Toggle"] = Instances:Create("TextButton", {
                Parent = Toggle.Section.Elements["Content"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                BackgroundTransparency = 1,
                Name = "\0",
                Size = UDim2New(1, 0, 0, 11),
                BorderSizePixel = 0,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Indicator"] = Instances:Create("Frame", {
                Parent = Items["Toggle"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(0, 10, 0, 10),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(33, 33, 36)
            })  Items["Indicator"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Indicator"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Instances:Create("UIGradient", {
                Parent = Items["Indicator"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Toggle"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                TextTransparency = 0.48,
                Text = Toggle.Name,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                Position = UDim2New(0, 18, 0, -1),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                BorderSizePixel = 0,
                BorderColor3 = FromRGB(0, 0, 0),
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            Items["Toggle"]:OnHover(function()
                if Toggle.Value then 
                    return 
                end

                Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
                Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
            end)

            Items["Toggle"]:OnHoverLeave(function()
                if Toggle.Value then 
                    return 
                end

                Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
                Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
            end)
        end
        
        function Toggle:Get()
            return Toggle.Value
        end

        function Toggle:Set(Bool)
            Toggle.Value = Bool or not Toggle.Value

            Library.Flags[Toggle.Flag] = Toggle.Value

            if Toggle.Value then 
                Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Accent"})

                Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme.Accent})
                Items["Text"]:Tween(nil, {TextTransparency = 0})
            else
                Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Element"})

                Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme.Element})
                Items["Text"]:Tween(nil, {TextTransparency = 0.48})
            end

            if Toggle.Callback then 
                Library:SafeCall(Toggle.Callback, Toggle.Value)
            end
        end

        function Toggle:SetVisiblity(Bool)
            Items["Toggle"].Instance.Visible = Bool
        end

        function Toggle:Colorpicker(Data)
            Data = Data or { }

            local Colorpicker = {
                Window = self.Window,
                Tab = self.Tab,
                Section = self.Section,

                Parent = Items["Toggle"],
                Name = Data.Name or Data.name or "Colorpicker",
                Flag = Data.Flag or Data.flag or Library:NextFlag(),
                Default = Data.Default or Data.default or Color3.fromRGB(255, 255, 255),
                Callback = Data.Callback or Data.callback or function() end,
                Alpha = Data.Alpha or Data.alpha or false,
                Count = Toggle.Count,

                FadeSpeed = self.Window.FadeSpeed
            }

            Toggle.Count += 1
            Colorpicker.Count = Toggle.Count

            local Extension = Library:CreateColorpicker(Colorpicker)
            Library.Flags[Colorpicker.Flag] = Extension

            return Colorpicker
        end

        function Toggle:Keybind(Data)
            Data = Data or { }

            local Keybind = {
                Window = self.Window,
                Tab = self.Tab,
                Section = self.Section,

                Parent = Items["Toggle"],
                Name = Data.Name or Data.name or "Keybind",
                Flag = Data.Flag or Data.flag or Library:NextFlag(),
                Default = Data.Default or Data.default or "MB2",
                Mode = Data.Mode or Data.mode or "Toggle",
                Callback = Data.Callback or Data.callback or function() end,
            }

            local Extension = Library:CreateKeybind(Keybind)
            Library.Flags[Keybind.Flag] = Extension

            return Keybind, Extension
        end

        Items["Toggle"]:Connect("MouseButton1Down", function()
            Toggle:Set()
        end)

        if Toggle.Default then 
            Toggle:Set(Toggle.Default)
        end

        Library.SetFlags[Toggle.Flag] = function(Value)
            Toggle:Set(Value)
        end

        return Toggle
    end

    Library.Sections.Button = function(self, Data)
        Data = Data or { }

        local Button = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Name = Data.Name or Data.name,
            Callback = Data.Callback or Data.callback or function() end,
        }

        local Items = { } do 
            Items["Button"] = Instances:Create("TextButton", {
                Parent = Button.Section.Elements["Content"].Instance,
                BorderColor3 = FromRGB(10, 10, 10),
                AutoButtonColor = false,
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                Size = UDim2New(1, 0, 0, 17),
                Selectable = false,
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(33, 33, 36)
            })  Items["Button"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})

            Instances:Create("UIGradient", {
                Parent = Items["Button"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["Button"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"}) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Button"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Button.Name,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BackgroundTransparency = 1,
                TextTruncate = Enum.TextTruncate.AtEnd,
                Position = UDim2New(0, 0, 0, -1),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Items["TextBorder"] = Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            Items["Button"]:OnHover(function()
                Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
                Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
            end)

            Items["Button"]:OnHoverLeave(function()
                Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
                Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
            end)
        end

        function Button:Press()
            Library:SafeCall(Button.Callback)

            Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
            Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Accent"})

            Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
            Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme.Accent})

            task.wait(0.1)

            Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
            Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Element"})

            Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text})
            Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme.Element})
        end

        function Button:SetVisiblity(Bool)
            Items["Button"].Instance.Visible = Bool
        end

        Items["Button"]:Connect("MouseButton1Down", function()
            Button:Press()
        end)

        return Button
    end

    Library.Sections.Slider = function(self, Data)
        Data = Data or { }

        local Slider = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Name = Data.Name or Data.name or "Slider",
            Flag = Data.Flag or Data.flag or Library:NextFlag(),
            Min = Data.Min or Data.min or 0,
            Default = Data.Default or Data.default or 0,
            Max = Data.Max or Data.max or 100,
            Suffix = Data.Suffix or Data.suffix or "",
            Decimals = Data.Decimals or Data.decimals or 1,
            Callback = Data.Callback or Data.callback or function() end,
            Compact = Data.Compact or Data.compact or false,

            Value = 0,
            Sliding = false,
            Class = "Slider",
        }

        local Items = { } do 
            Items["Slider"] = Instances:Create("Frame", {
                Parent = Slider.Section.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 27),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Slider"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Slider.Name,
                Name = "\0",
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Size = UDim2New(1, 0, 0, 13),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["RealSlider"] = Instances:Create("TextButton", {
                Parent = Items["Slider"].Instance,
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Text = "",
                AutoButtonColor = false,
                Size = UDim2New(1, 0, 0, 10),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(33, 33, 36)
            })  Items["RealSlider"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["RealSlider"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Instances:Create("UIGradient", {
                Parent = Items["RealSlider"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Items["Indicator"] = Instances:Create("Frame", {
                Parent = Items["RealSlider"].Instance,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(0.5, 0, 1, 0),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(235, 157, 255)
            })  Items["Indicator"]:AddToTheme({BackgroundColor3 = "Accent"})
            
            Instances:Create("UIGradient", {
                Parent = Items["Indicator"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Items["Value"] = Instances:Create("TextLabel", {
                Parent = Items["RealSlider"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "50/100s",
                Name = "\0",
                BackgroundTransparency = 1,
                Position = UDim2New(0, 0, 0, -1),
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Value"]:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = Items["Value"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            if Slider.Compact then 
                Items["Value"]:Clean()
                Items["Value"] = nil

                Items["Slider"].Instance.Size = UDim2New(1,0,0,10)
                Items["Text"].Instance.Parent = Items["RealSlider"].Instance
                Items["Text"].Instance.Position = UDim2New(0,0,0,-2)
                Items["Text"].Instance.TextXAlignment = Enum.TextXAlignment.Center
            end

            Items["RealSlider"]:OnHover(function()
                Items["RealSlider"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
                Items["RealSlider"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
            end)

            Items["RealSlider"]:OnHoverLeave(function()
                Items["RealSlider"]:Tween(nil, {BackgroundColor3 = Library.Theme["Background"]})
                Items["RealSlider"]:ChangeItemTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            end)
        end

        function Slider:Set(Value)
            Slider.Value = MathClamp(Library:Round(Value, Slider.Decimals), Slider.Min, Slider.Max)

            Library.Flags[Slider.Flag] = Slider.Value
            
            if Slider.Compact then
                Items["Text"].Instance.Text = `{Slider.Name}: {Slider.Value}{Slider.Suffix}`
            else
                Items["Value"].Instance.Text = `{Slider.Value}{Slider.Suffix}`
            end

            Items["Indicator"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2New((Slider.Value - Slider.Min) / (Slider.Max - Slider.Min), 0, 1, 0)})

            if Slider.Callback then 
                Library:SafeCall(Slider.Callback, Slider.Value)
            end
        end

        function Slider:Get()
            return Slider.Value
        end

        function Slider:SetVisibility(Bool)
            Items["Slider"].Instance.Visible = Bool
        end

        Items["RealSlider"]:Connect("MouseButton1Down", function()
            Slider.Sliding = true

            local MousePos = UserInputService:GetMouseLocation()

            local SizeX = (MousePos.X - Items["RealSlider"].Instance.AbsolutePosition.X) / Items["RealSlider"].Instance.AbsoluteSize.X
            local Value = ((Slider.Max - Slider.Min) * SizeX) + Slider.Min

            Slider:Set(Value)
        end)

        Items["RealSlider"]:Connect("InputEnded", function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseButton1 then
                Slider.Sliding = false
            end
        end)

        Library:Connect(UserInputService.InputChanged, function(Input)
            if Input.UserInputType == Enum.UserInputType.MouseMovement and Slider.Sliding then
                local MousePos = UserInputService:GetMouseLocation()

                local SizeX = (MousePos.X - Items["RealSlider"].Instance.AbsolutePosition.X) / Items["RealSlider"].Instance.AbsoluteSize.X
                local Value = ((Slider.Max - Slider.Min) * SizeX) + Slider.Min

                Slider:Set(Value)
            end
        end)

        if Slider.Default then
            Slider:Set(Slider.Default)
        end

        Library.SetFlags[Slider.Flag] = function(Value)
            Slider:Set(Value)
        end

        return Slider
    end

    Library.Sections.Dropdown = function(self, Data)
        Data = Data or { }

        local Dropdown = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Name = Data.Name or Data.name or "Dropdown",
            Flag = Data.Flag or Data.flag or Library:NextFlag(),
            Items = Data.Items or Data.items or { "One", "Two", "Three" },
            Default = Data.Default or Data.default or nil,
            Callback = Data.Callback or Data.callback or function() end,
            Multi = Data.Multi or Data.multi or false,

            Value = { },
            IsOpen = false,
            Options = { },
            Class = "Dropdown",
        }

        local Items = { } do
            Items["Dropdown"] = Instances:Create("Frame", {
                Parent = Dropdown.Section.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 34),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Dropdown"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Dropdown.Name,
                Name = "\0",
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Size = UDim2New(1, 0, 0, 13),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["RealDropdown"] = Instances:Create("Frame", {
                Parent = Items["Dropdown"].Instance,
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(1, 0, 0, 17),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(33, 33, 36)
            })  Items["RealDropdown"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            
            Instances:Create("UIGradient", {
                Parent = Items["RealDropdown"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["RealDropdown"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Open"] = Instances:Create("TextButton", {
                Parent = Items["RealDropdown"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "+",
                AutoButtonColor = false,
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Right,
                Position = UDim2New(0, -4, 0, -1),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Open"]:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = Items["Open"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"}) 
            
            Items["Value"] = Instances:Create("TextLabel", {
                Parent = Items["RealDropdown"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "--",
                Name = "\0",
                Size = UDim2New(1, -25, 1, 0),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                TextTruncate = Enum.TextTruncate.AtEnd,
                Position = UDim2New(0, 5, 0, -1),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Value"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Value"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["OptionHolder"] = Instances:Create("Frame", {
                Parent = Items["Dropdown"].Instance,
                Visible = false,
                BorderColor3 = FromRGB(10, 10, 10),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 5),
                Size = UDim2New(1, 0, 0, 0),
                BorderSizePixel = 2,
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = FromRGB(20, 20, 25)
            })  Items["OptionHolder"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["OptionHolder"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})

            Instances:Create("UIListLayout", {
                Parent = Items["OptionHolder"].Instance,
                SortOrder = Enum.SortOrder.LayoutOrder
            }) 
            
            Instances:Create("UIPadding", {
                Parent = Items["OptionHolder"].Instance,
                PaddingBottom = UDimNew(0, 2)
            })

            Items["RealDropdown"]:OnHover(function()
                Items["RealDropdown"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
                Items["RealDropdown"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
            end)

            Items["RealDropdown"]:OnHoverLeave(function()
                Items["RealDropdown"]:Tween(nil, {BackgroundColor3 = Library.Theme["Background"]})
                Items["RealDropdown"]:ChangeItemTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
            end)
        end

        function Dropdown:Set(Option)
            if Dropdown.Multi then 
                if type(Option) ~= "table" then 
                    return
                end

                Dropdown.Value = Option

                for Index, Value in Option do 
                    local OptionData = Dropdown.Options[Value]
                    
                    if not OptionData then 
                        return
                    end

                    OptionData.Selected = true
                    OptionData:Toggle("Active")
                end

                Library.Flags[Dropdown.Flag] = Dropdown.Value

                Items["Value"].Instance.Text = TableConcat(Option, ", ")
            else
                if not Dropdown.Options[Option] then 
                    return
                end

                local OptionData = Dropdown.Options[Option]

                Dropdown.Value = OptionData.Name

                OptionData.Selected = true
                OptionData:Toggle("Active")

                for Index, Value in Dropdown.Options do 
                    if Value ~= OptionData then 
                        Value.Selected = false
                        Value:Toggle("Inactive")
                    end
                end

                Library.Flags[Dropdown.Flag] = Dropdown.Value

                Items["Value"].Instance.Text = Option
            end

            if Dropdown.Callback then 
                Library:SafeCall(Dropdown.Callback, Option)
            end
        end

        function Dropdown:Get()
            return Dropdown.Value
        end

        function Dropdown:SetVisibility(Bool)
            Items["Dropdown"].Instance.Visible = Bool
        end

        function Dropdown:Add(Option)
            local OptionButton = Instances:Create("TextButton", {
                Parent = Items["OptionHolder"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                Name = "\0",
                BackgroundTransparency = 1,
                BorderSizePixel = 0,
                Size = UDim2New(1, 0, 0, 15),
                ZIndex = 5,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            local OptionText = Instances:Create("TextLabel", {
                Parent = OptionButton.Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                TextTransparency = 0.48,
                Text = Option,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -5, 1, 0),
                Position = UDim2New(0, 5, 0, 0),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                BorderSizePixel = 0,
                ZIndex = 5,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            OptionText:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = OptionText.Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            local OptionData = {
                Selected = false,
                Name = Option,
                Text = OptionText,
                Button = OptionButton
            }

            function OptionData:Toggle(State)
                if State == "Active" then 
                    OptionData.Text:ChangeItemTheme({TextColor3 = "Accent"})
                    OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
                else
                    OptionData.Text:ChangeItemTheme({TextColor3 = "Text"})
                    OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.48})
                end
            end

            function OptionData:Set()
                OptionData.Selected = not OptionData.Selected

                if Dropdown.Multi then
                    local Index = TableFind(Dropdown.Value, OptionData.Name)

                    if Index then 
                        TableRemove(Dropdown.Value, Index)
                    else
                        TableInsert(Dropdown.Value, OptionData.Name)
                    end

                    Library.Flags[Dropdown.Flag] = Dropdown.Value

                    OptionData:Toggle(Index and "Inactive" or "Active")

                    local TextFormat = #Dropdown.Value > 0 and TableConcat(Dropdown.Value, ", ") or "--"

                    Items["Value"].Instance.Text = TextFormat
                else
                    if OptionData.Selected then
                        Dropdown.Value = OptionData.Name

                        Library.Flags[Dropdown.Flag] = Dropdown.Value

                        OptionData:Toggle("Active")
                        Items["Value"].Instance.Text = OptionData.Name

                        for Index, Value in Dropdown.Options do 
                            if Value ~= OptionData then 
                                Value.Selected = false
                                Value:Toggle("Inactive")
                            end
                        end
                    else
                        Dropdown.Value = nil

                        OptionData:Toggle("Inactive")
                        Items["Value"].Instance.Text = "--"
                    end
                end

                if Dropdown.Callback then 
                    Library:SafeCall(Dropdown.Callback, Dropdown.Value)
                end
            end

            OptionButton:Connect("MouseButton1Down", function()
                OptionData:Set()
            end)

            Dropdown.Options[Option] = OptionData
            return OptionData
        end

        function Dropdown:Remove(Option)
            if Dropdown.Options[Option] then 
                Dropdown.Options[Option].Button:Clean()
            end
        end

        function Dropdown:Refresh(List)
            for Index, Value in Dropdown.Options do 
                Dropdown:Remove(Value.Name)
            end

            for Index, Value in List do 
                Dropdown:Add(Value)
            end
        end

        local Debounce = false

        function Dropdown:SetOpen(Bool)
            if Debounce then 
                return 
            end

            Dropdown.IsOpen = Bool

            Debounce = true 

            if Bool then 
                Items["OptionHolder"].Instance.Visible = true
                Items["OptionHolder"].Instance.ZIndex = 15
                Items["Open"].Instance.Text = "-"
                Items["Open"].Instance.Position = UDim2New(0, -5, 0, -1)
            else
                Items["Open"].Instance.Text = "+"
                Items["Open"].Instance.Position = UDim2New(0, -4, 0, -1)
            end

            local Descendants = Items["OptionHolder"].Instance:GetDescendants()
            TableInsert(Descendants, Items["OptionHolder"].Instance)

            local NewTween
            for Index, Value in Descendants do 
                local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)

                if not ValueIndex then 
                    continue
                end

                if not StringFind(Value.ClassName, "UI") then 
                    Value.ZIndex = Bool and 15 or 1
                end

                if type(ValueIndex) == "table" then
                    for _, Property in ValueIndex do 
                        NewTween = Library:FadeItem(Value, Property, Bool, Dropdown.Window.FadeSpeed)
                    end
                else
                    NewTween = Library:FadeItem(Value, ValueIndex, Bool, Dropdown.Window.FadeSpeed)
                end
            end

            Library:Connect(NewTween.Tween.Completed, function()
                Debounce = false
                Items["OptionHolder"].Instance.Visible = Bool
                Items["OptionHolder"].Instance.ZIndex = Bool and 15 or 1
            end)
        end

        for Index, Value in Dropdown.Items do 
            Dropdown:Add(Value)
        end

        Items["Open"]:Connect("MouseButton1Down", function()
            Dropdown:SetOpen(not Dropdown.IsOpen)
        end)

        if Dropdown.Default then 
            Dropdown:Set(Dropdown.Default)
        end

        Library.SetFlags[Dropdown.Flag] = function(Value)
            Dropdown:Set(Value)            
        end

        return Dropdown
    end

    Library.Sections.Label = function(self, Data)
        Data = Data or { }

        local Label = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Name = Data.Name or Data.name,
            Alignment = Data.Alignment or Data.alignment or "Left",

            Count = 0
        }

        local Items = { } do 
            Items["Label"] = Instances:Create("Frame", {
                Parent = Label.Section.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 15),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Label"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Label.Name,
                Name = "\0",
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment[Label.Alignment],
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
            }):AddToTheme({Color = "Text Border"})
        end

        function Label:Colorpicker(Data)
            Data = Data or { }

            local Colorpicker = {
                Window = self.Window,
                Tab = self.Tab,
                Section = self.Section,

                Parent = Items["Label"],
                Name = Data.Name or Data.name or "Colorpicker",
                Flag = Data.Flag or Data.flag or Library:NextFlag(),
                Default = Data.Default or Data.default or Color3.fromRGB(255, 255, 255),
                Callback = Data.Callback or Data.callback or function() end,
                Alpha = Data.Alpha or Data.alpha or false,
                Count = Label.Count,
                FadeSpeed = self.Window.FadeSpeed
            }

            Label.Count += 1
            Colorpicker.Count = Label.Count

            local Extension = Library:CreateColorpicker(Colorpicker)
            
            return Colorpicker, Extension
        end

        function Label:Keybind(Data)
            Data = Data or { }

            local Keybind = {
                Window = self.Window,
                Tab = self.Tab,
                Section = self.Section,

                Parent = Items["Label"],
                Name = Data.Name or Data.name or "Keybind",
                Flag = Data.Flag or Data.flag or Library:NextFlag(),
                Default = Data.Default or Data.default or "MB2",
                Mode = Data.Mode or Data.mode or "Toggle",
                Callback = Data.Callback or Data.callback or function() end,
            }

            local Extension = Library:CreateKeybind(Keybind)

            return Keybind, Extension
        end

        return Label
    end

    Library.Sections.Textbox = function(self, Data)
        Data = Data or { }

        local Textbox = {
            Window = self.Window,
            Tab = self.Tab,
            Section = self,

            Name = Data.Name or Data.name or "Textbox",
            Flag = Data.Flag or Data.flag or Library:NextFlag(),
            Placeholder = Data.Placeholder or Data.placeholder or "...",
            Default = Data.Default or Data.default or "",
            Callback = Data.Callback or Data.callback or function() end,

            Value = "",
            Class = "Textbox"
        }

        local Items = { } do 
            Items["Textbox"] = Instances:Create("Frame", {
                Parent = Textbox.Section.Elements["Content"].Instance,
                BackgroundTransparency = 1,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, 0, 0, 34),
                BorderSizePixel = 0,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["Text"] = Instances:Create("TextLabel", {
                Parent = Items["Textbox"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = Textbox.Name,
                Name = "\0",
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Left,
                Size = UDim2New(1, 0, 0, 13),
                BorderSizePixel = 0,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Text"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIStroke", {
                Parent = Items["Text"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})
            
            Items["Background"] = Instances:Create("Frame", {
                Parent = Items["Textbox"].Instance,
                AnchorPoint = Vector2New(0, 1),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                BorderColor3 = FromRGB(10, 10, 10),
                Size = UDim2New(1, 0, 0, 17),
                BorderSizePixel = 2,
                BackgroundColor3 = FromRGB(33, 33, 36)
            })  Items["Background"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
            
            Instances:Create("UIGradient", {
                Parent = Items["Background"].Instance,
                Rotation = 90,
                Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["Background"].Instance,
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0",
                Color = FromRGB(27, 27, 32)
            }):AddToTheme({Color = "Outline"})
            
            Items["Inline"] = Instances:Create("TextBox", {
                Parent = Items["Background"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                Name = "\0",
                Size = UDim2New(1, 0, 1, 0),
                BorderSizePixel = 0,
                ClearTextOnFocus = false,
                BackgroundTransparency = 1,
                PlaceholderColor3 = FromRGB(178, 178, 178),
                TextXAlignment = Enum.TextXAlignment.Left,
                PlaceholderText = Textbox.Placeholder,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            })  Items["Inline"]:AddToTheme({TextColor3 = "Text"})
            
            Instances:Create("UIPadding", {
                Parent = Items["Inline"].Instance,
                PaddingBottom = UDimNew(0, 3),
                PaddingLeft = UDimNew(0, 5)
            }) 
            
            Instances:Create("UIStroke", {
                Parent = Items["Inline"].Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            Items["Background"]:OnHover(function()
                Items["Background"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
                Items["Background"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
            end)

            Items["Background"]:OnHoverLeave(function()
                Items["Background"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
                Items["Background"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
            end)
        end

        function Textbox:Get()
            return Textbox.Value
        end

        function Textbox:SetVisibility(Bool)
            Items["Textbox"].Instance.Visible = Bool
        end

        function Textbox:Set(Value)
            Textbox.Value = Value
            
            Items["Inline"].Instance.Text = Textbox.Value
            Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Text})
            Items["Inline"]:ChangeItemTheme({TextColor3 = "Text"})

            Library.Flags[Textbox.Flag] = Textbox.Value

            if Textbox.Callback then
                Library:SafeCall(Textbox.Callback, Textbox.Value)
            end
        end

        Items["Inline"]:Connect("Focused", function()
            Items["Inline"]:ChangeItemTheme({TextColor3 = "Accent"})
            Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
        end)

        Items["Inline"]:Connect("FocusLost", function()
            Items["Inline"]:ChangeItemTheme({TextColor3 = "Text"})
            Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Text})

            Textbox:Set(Items["Inline"].Instance.Text)
        end)

        if Textbox.Default then
            Textbox:Set(Textbox.Default)
        end

        Library.SetFlags[Textbox.Flag] = function(Value)
            Textbox:Set(Value)
        end

        return Textbox
    end
    
    Library.Sections.Listbox = function(self, Data)
        Data = Data or {}

        local Listbox = {
            Window = self.Window,
            Page = self.Page,
            Section = self,

            Items = Data.Items or Data.items or { },
            Multi = Data.Multi or Data.multi or false,
            Default = Data.Default or Data.default or 1,
            Flag = Data.Flag or Data.flag or Library:NextFlag(),
            Callback = Data.Callback or Data.callback or function() end,
            Size = Data.Size or Data.size or 175,

            Value = { },
            Options = { },
            Class = "Listbox",
        }

        local Items = { } do 
            Items["Listbox"] = Instances:Create("Frame", {
                Parent = Listbox.Section.Elements["Content"].Instance,
                Name = "\0",
                BackgroundTransparency = 1,
                Size = UDim2New(1, 0, 0, Listbox.Size),
                BorderColor3 = FromRGB(0, 0, 0),
                BorderSizePixel = 0,
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            Items["RealListbox"] = Instances:Create("ScrollingFrame", {
                Parent = Items["Listbox"].Instance,
                ScrollBarImageColor3 = FromRGB(235, 157, 255),
                Active = true,
                AutomaticCanvasSize = Enum.AutomaticSize.Y,
                ScrollBarThickness = 1,
                AnchorPoint = Vector2New(0, 1),
                Size = UDim2New(1, 0, 1, 0),
                Name = "\0",
                Position = UDim2New(0, 0, 1, 0),
                BackgroundColor3 = FromRGB(15, 15, 20),
                BorderColor3 = FromRGB(10, 10, 10),
                BorderSizePixel = 2,
                CanvasSize = UDim2New(0, 0, 0, 0)
            })  Items["RealListbox"]:AddToTheme({ScrollBarImageColor3 = "Accent", BackgroundColor3 = "Background", BorderColor3 = "Border"})
            
            Instances:Create("UIStroke", {
                Parent = Items["RealListbox"].Instance,
                Color = FromRGB(27, 27, 32),
                Name = "\0",
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border
            }):AddToTheme({Color = "Outline"}) 
            
            Instances:Create("UIListLayout", {
                Parent = Items["RealListbox"].Instance,
                SortOrder = Enum.SortOrder.LayoutOrder
            }) 

            Instances:Create("UIPadding", {
                Parent = Items["RealListbox"].Instance,
                PaddingBottom = UDimNew(0, 5),
                PaddingTop = UDimNew(0, 2)
            }) 
        end

        function Listbox:Set(Option)
            if Listbox.Multi then 
                if type(Option) ~= "table" then 
                    return
                end

                Listbox.Value = Option

                Library.Flags[Listbox.Flag] = Listbox.Value

                for Index, Value in Option do 
                    local OptionData = Listbox.Options[Value]
                    
                    if not OptionData then 
                        return
                    end

                    OptionData.Selected = true
                    OptionData:Toggle("Active")
                end
            else
                if not Listbox.Options[Option] then 
                    return
                end

                local OptionData = Listbox.Options[Option]

                Listbox.Value = OptionData.Name
                
                Library.Flags[Listbox.Flag] = Listbox.Value

                OptionData.Selected = true
                OptionData:Toggle("Active")

                for Index, Value in Listbox.Options do 
                    if Value ~= OptionData then 
                        Value.Selected = false
                        Value:Toggle("Inactive")
                    end
                end
            end

            if Listbox.Callback then 
                Library:SafeCall(Listbox.Callback, Option)
            end
        end

        function Listbox:Get()
            return Listbox.Value
        end

        function Listbox:SetVisibility(Bool)
            Items["Listbox"].Instance.Visible = Bool
        end

        function Listbox:Remove(Option)
            if Listbox.Options[Option] then 
                Listbox.Options[Option].Button:Clean()
            end
        end

        function Listbox:Refresh(List)
            for Index, Value in Listbox.Options do 
                Listbox:Remove(Value.Name)
            end

            for Index, Value in List do 
                Listbox:Add(Value)
            end
        end

        function Listbox:Add(Option)
            local OptionButton = Instances:Create("TextButton", {
                Parent = Items["RealListbox"].Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(0, 0, 0),
                BorderColor3 = FromRGB(0, 0, 0),
                Text = "",
                AutoButtonColor = false,
                Name = "\0",
                BackgroundTransparency = 1,
                BorderSizePixel = 0,
                Size = UDim2New(1, 0, 0, 15),
                ZIndex = 5,
                TextSize = 14,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            local OptionText = Instances:Create("TextLabel", {
                Parent = OptionButton.Instance,
                FontFace = Library.Font,
                TextColor3 = FromRGB(215, 215, 215),
                TextTransparency = 0.48,
                Text = Option,
                Name = "\0",
                BorderColor3 = FromRGB(0, 0, 0),
                Size = UDim2New(1, -5, 1, 0),
                Position = UDim2New(0, 5, 0, 0),
                BackgroundTransparency = 1,
                TextXAlignment = Enum.TextXAlignment.Center,
                BorderSizePixel = 0,
                ZIndex = 5,
                TextSize = 12,
                BackgroundColor3 = FromRGB(255, 255, 255)
            }) 
            
            OptionText:AddToTheme({TextColor3 = "Text"})

            Instances:Create("UIStroke", {
                Parent = OptionText.Instance,
                LineJoinMode = Enum.LineJoinMode.Miter,
                Name = "\0"
            }):AddToTheme({Color = "Text Border"})

            local OptionData = {
                Selected = false,
                Name = Option,
                Text = OptionText,
                Button = OptionButton
            }

            function OptionData:Toggle(State)
                if State == "Active" then 
                    OptionData.Text:ChangeItemTheme({TextColor3 = "Accent"})
                    OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
                else
                    OptionData.Text:ChangeItemTheme({TextColor3 = "Text"})
                    OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.48})
                end
            end

            function OptionData:Set()
                OptionData.Selected = not OptionData.Selected

                if Listbox.Multi then
                    local Index = TableFind(Listbox.Value, OptionData.Name)

                    if Index then 
                        TableRemove(Listbox.Value, Index)
                    else
                        TableInsert(Listbox.Value, OptionData.Name)
                    end

                    OptionData:Toggle(Index and "Inactive" or "Active")

                    local TextFormat = #Listbox.Value > 0 and TableConcat(Listbox.Value, ", ") or "--"
                else
                    if OptionData.Selected then
                        Listbox.Value = OptionData.Name

                        OptionData:Toggle("Active")

                        for Index, Value in Listbox.Options do 
                            if Value ~= OptionData then 
                                Value.Selected = false
                                Value:Toggle("Inactive")
                            end
                        end
                    else
                        Listbox.Value = nil

                        OptionData:Toggle("Inactive")
                    end
                end

                if Listbox.Callback then 
                    Library:SafeCall(Listbox.Callback, Listbox.Value)
                end
            end

            OptionButton:Connect("MouseButton1Down", function()
                OptionData:Set()
            end)

            Listbox.Options[Option] = OptionData
            return OptionData
        end

        for Index, Value in Listbox.Items do 
            Listbox:Add(Value)
        end

        if Listbox.Default then 
            Listbox:Set(Listbox.Default)
        end

        Library.SetFlags[Listbox.Flag] = function(Value)
            Listbox:Set(Value)
        end

        return Listbox
    end
end
--
local Window = Library:Window({
    Name = "MEOW.GG - Hood Customs | Ver. 0.7.5 | Build - Private ",
    Size = UDim2.new(0, 666, 0, 666),
    FadeSpeed = 0.25
})

local Watermark = Library:Watermark("MEOW.GG | Build - Private | Uid - ? ")
local KeybindList = Library:KeybindList()

Watermark:SetVisibility(false)
KeybindList:SetVisibility(false)







local RageTab = Window:Page({Name = "Rage", Columns = 2, Subtabs = false})





















































local LegitTab = Window:Page({Name = "Legit", Columns = 2, Subtabs = false})











do -- Legit Aim Assist
    -- Services
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer
    local Camera = workspace.CurrentCamera
    local Mouse = LocalPlayer:GetMouse()
    
    -- State Variables
    local AimAssistEnabled = false
    local AimAssistActive = false
    local ShowFOV = false
    local StickyAimActive = false
    local CurrentTarget = nil
    local LockedTarget = nil -- This will store the locked target for sticky aim
    local LastAimTime = 0
    
    -- FOV Circles
    local FOVCircle = nil
    local FOVOutline = nil
    
    -- Settings
    local Settings = {
        -- Core Settings
        Enabled = false,
        Smoothness = 8,
        SmoothingType = "Linear", -- Linear, Exponential, Sine
        
        -- Target Settings
        HitPart = "Head",
        TargetPriority = "Closest to Crosshair",
        
        -- FOV Settings
        FOVSize = 100,
        FOVColor = Color3.fromRGB(255, 255, 255),
        FOVThickness = 2,
        FOVFilled = true,
        FOVTransparency = 85,
        FOVOutlineColor = Color3.fromRGB(0, 0, 0),
        FOVOutlineThickness = 3,
        ShowFOV = false,
        DynamicFOV = false,
        DynamicFOVIntensity = 50,
        
        -- Checks
        TeamCheck = true,
        VisibleCheck = true,
        AliveCheck = true,
        ForceFieldCheck = true,
        
        -- Advanced Features
        StickyAim = false,
        ShakeReduction = 0,
        AimAcceleration = false,
        AccelerationSpeed = 15,
        MaxAimSpeed = 100,
        AimDeadzone = 5,
        IgnoreTeammates = true,
        
        -- Humanization
        ReactionTime = 50,
        MissChance = 0,
        NaturalSway = false,
        SwayIntensity = 2,
        
        -- Distance
        MaxDistance = 500,
        DistanceCheck = false
    }
    
    -- Helper Functions
    local function GetClosestPartToMouse(character)
        if not character then return nil end
        
        local parts = {
            "Head",
            "UpperTorso", "Torso",
            "LowerTorso",
            "HumanoidRootPart"
        }
        
        local closestPart = nil
        local closestDistance = math.huge
        local mousePos = UserInputService:GetMouseLocation()
        
        for _, partName in ipairs(parts) do
            local part = character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local distance = math.sqrt(
                        (screenPos.X - mousePos.X)^2 + 
                        (screenPos.Y - mousePos.Y)^2
                    )
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPart = part
                    end
                end
            end
        end
        
        return closestPart
    end
    
    local function GetHitPart(character)
        if not character then return nil end
        
        if Settings.HitPart == "Closest Part" then
            return GetClosestPartToMouse(character)
        end
        
        local partNames = {
            ["Head"] = "Head",
            ["Neck"] = "Head",
            ["Upper Chest"] = "UpperTorso",
            ["Chest"] = "UpperTorso",
            ["Lower Chest"] = "LowerTorso",
            ["Stomach"] = "LowerTorso",
            ["Pelvis"] = "LowerTorso"
        }
        
        local partName = partNames[Settings.HitPart] or "HumanoidRootPart"
        local part = character:FindFirstChild(partName)
        
        if not part then
            part = character:FindFirstChild("HumanoidRootPart")
        end
        
        return part
    end
    
    local function IsPlayerValid(player)
        if not player or player == LocalPlayer then return false end
        if not player.Character then return false end
        
        -- Team Check
        if Settings.TeamCheck and player.Team == LocalPlayer.Team then
            return false
        end
        
        -- Alive Check
        if Settings.AliveCheck then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return false
            end
        end
        
        -- ForceField Check
        if Settings.ForceFieldCheck then
            if player.Character:FindFirstChildOfClass("ForceField") then
                return false
            end
        end
        
        return true
    end
    
    local function IsVisible(targetPart)
        if not Settings.VisibleCheck then return true end
        if not targetPart then return false end
        
        local origin = Camera.CFrame.Position
        local direction = (targetPart.Position - origin).Unit * 1000
        
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = {Camera, LocalPlayer.Character}
        rayParams.IgnoreWater = true
        
        local result = workspace:Raycast(origin, direction, rayParams)
        
        if not result then return false end
        
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    
    local function GetDistanceFromCamera(position)
        return (Camera.CFrame.Position - position).Magnitude
    end
    
    local function IsInFOV(targetPart)
        if not targetPart then return false end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then return false end
        
        local mousePos = UserInputService:GetMouseLocation()
        local distance = math.sqrt(
            (screenPos.X - mousePos.X)^2 + 
            (screenPos.Y - mousePos.Y)^2
        )
        
        local fovSize = Settings.FOVSize
        
        -- Dynamic FOV based on distance
        if Settings.DynamicFOV then
            local dist = GetDistanceFromCamera(targetPart.Position)
            local scale = math.clamp(1 - (dist / 1000), 0.5, 1.5)
            fovSize = fovSize * scale * (Settings.DynamicFOVIntensity / 100)
        end
        
        return distance <= fovSize
    end
    
    local function GetDistanceToMouse(targetPart)
        if not targetPart then return math.huge end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then return math.huge end
        
        local mousePos = UserInputService:GetMouseLocation()
        return math.sqrt(
            (screenPos.X - mousePos.X)^2 + 
            (screenPos.Y - mousePos.Y)^2
        )
    end
    
    local function GetBestTarget()
        local bestTarget = nil
        local bestValue = math.huge
        
        for _, player in ipairs(Players:GetPlayers()) do
            if IsPlayerValid(player) then
                local character = player.Character
                local targetPart = GetHitPart(character)
                
                if targetPart then
                    -- Distance Check
                    if Settings.DistanceCheck then
                        local distance = GetDistanceFromCamera(targetPart.Position)
                        if distance > Settings.MaxDistance then
                            continue
                        end
                    end
                    
                    -- FOV Check
                    if not IsInFOV(targetPart) then
                        continue
                    end
                    
                    -- Visibility Check
                    if not IsVisible(targetPart) then
                        continue
                    end
                    
                    -- Calculate priority value
                    local value
                    if Settings.TargetPriority == "Closest to Crosshair" then
                        value = GetDistanceToMouse(targetPart)
                    elseif Settings.TargetPriority == "Closest Distance" then
                        value = GetDistanceFromCamera(targetPart.Position)
                    elseif Settings.TargetPriority == "Lowest Health" then
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        value = humanoid and humanoid.Health or math.huge
                    end
                    
                    if value < bestValue then
                        bestValue = value
                        bestTarget = targetPart
                    end
                end
            end
        end
        
        return bestTarget
    end
    
    local function IsLockedTargetValid()
        if not LockedTarget then return false end
        if not LockedTarget.Parent then return false end
        
        local character = LockedTarget.Parent
        local player = Players:GetPlayerFromCharacter(character)
        
        if not player then return false end
        if not IsPlayerValid(player) then return false end
        
        -- Check if target is still alive
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if Settings.AliveCheck and (not humanoid or humanoid.Health <= 0) then
            return false
        end
        
        return true
    end
    
    local function ApplySmoothing(currentPos, targetPos, deltaTime)
        local smoothness = Settings.Smoothness
        
        -- Aim Acceleration
        if Settings.AimAcceleration then
            local timeSinceLastAim = tick() - LastAimTime
            if timeSinceLastAim < 0.5 then
                local accelFactor = 1 + (Settings.AccelerationSpeed / 100)
                smoothness = smoothness / accelFactor
            end
        end
        
        -- Max Aim Speed
        local maxSpeed = Settings.MaxAimSpeed / 100
        smoothness = math.max(smoothness, 1 / maxSpeed)
        
        local alpha = 1 / (smoothness * 60 * deltaTime)
        alpha = math.clamp(alpha, 0, 1)
        
        -- Apply smoothing type
        if Settings.SmoothingType == "Exponential" then
            alpha = 1 - math.exp(-alpha * 4)
        elseif Settings.SmoothingType == "Sine" then
            alpha = math.sin(alpha * (math.pi / 2))
        end
        
        return currentPos:Lerp(targetPos, alpha)
    end
    
    local function ApplyShakeReduction(aimCFrame)
        if Settings.ShakeReduction <= 0 then return aimCFrame end
        
        local reductionFactor = Settings.ShakeReduction / 100
        local currentCFrame = Camera.CFrame
        
        return currentCFrame:Lerp(aimCFrame, 1 - (reductionFactor * 0.3))
    end
    
    local function ApplyNaturalSway(targetPos)
        if not Settings.NaturalSway then return targetPos end
        
        local time = tick() * 2
        local swayAmount = Settings.SwayIntensity / 100
        
        local offsetX = math.sin(time * 1.5) * swayAmount
        local offsetY = math.cos(time * 2.2) * swayAmount
        
        return targetPos + Vector3.new(offsetX, offsetY, 0)
    end
    
    local function ShouldMiss()
        return math.random(1, 100) <= Settings.MissChance
    end
    
    local function AimAt(targetPart, deltaTime)
        if not targetPart then return end
        if ShouldMiss() then return end
        
        -- Reaction Time Delay
        if tick() - LastAimTime < (Settings.ReactionTime / 1000) then
            return
        end
        
        local targetPos = targetPart.Position
        
        -- Apply Natural Sway
        targetPos = ApplyNaturalSway(targetPos)
        
        -- Calculate aim direction
        local aimCFrame = CFrame.new(Camera.CFrame.Position, targetPos)
        
        -- Apply Smoothing
        aimCFrame = ApplySmoothing(Camera.CFrame, aimCFrame, deltaTime)
        
        -- Apply Shake Reduction
        aimCFrame = ApplyShakeReduction(aimCFrame)
        
        -- Deadzone Check
        local mousePos = UserInputService:GetMouseLocation()
        local screenPos = Camera:WorldToViewportPoint(targetPos)
        local distanceToTarget = math.sqrt(
            (screenPos.X - mousePos.X)^2 + 
            (screenPos.Y - mousePos.Y)^2
        )
        
        if distanceToTarget <= Settings.AimDeadzone then
            return
        end
        
        Camera.CFrame = aimCFrame
        LastAimTime = tick()
    end
    
    -- FOV Circle Creation
    local function CreateFOVCircles()
        -- Outline (behind)
        if FOVOutline then FOVOutline:Remove() end
        FOVOutline = Drawing.new("Circle")
        FOVOutline.Thickness = Settings.FOVOutlineThickness
        FOVOutline.Color = Settings.FOVOutlineColor
        FOVOutline.NumSides = 64
        FOVOutline.Radius = Settings.FOVSize
        FOVOutline.Filled = false
        FOVOutline.Visible = false
        FOVOutline.Transparency = 1
        FOVOutline.ZIndex = 1
        
        -- Main Circle (front)
        if FOVCircle then FOVCircle:Remove() end
        FOVCircle = Drawing.new("Circle")
        FOVCircle.Thickness = Settings.FOVThickness
        FOVCircle.Color = Settings.FOVColor
        FOVCircle.NumSides = 64
        FOVCircle.Radius = Settings.FOVSize
        FOVCircle.Filled = Settings.FOVFilled
        FOVCircle.Visible = false
        FOVCircle.Transparency = Settings.FOVFilled and (Settings.FOVTransparency / 100) or 1
        FOVCircle.ZIndex = 2
    end
    
    local function UpdateFOVCircles()
        if not FOVCircle or not FOVOutline then return end
        
        local mousePos = UserInputService:GetMouseLocation()
        local fovSize = Settings.FOVSize
        
        -- Dynamic FOV
        if Settings.DynamicFOV and CurrentTarget then
            local dist = GetDistanceFromCamera(CurrentTarget.Position)
            local scale = math.clamp(1 - (dist / 1000), 0.5, 1.5)
            fovSize = fovSize * scale * (Settings.DynamicFOVIntensity / 100)
        end
        
        -- Update Outline
        FOVOutline.Position = Vector2.new(mousePos.X, mousePos.Y)
        FOVOutline.Radius = fovSize
        FOVOutline.Color = Settings.FOVOutlineColor
        FOVOutline.Thickness = Settings.FOVOutlineThickness
        FOVOutline.Visible = Settings.ShowFOV and AimAssistEnabled
        
        -- Update Main Circle
        FOVCircle.Position = Vector2.new(mousePos.X, mousePos.Y)
        FOVCircle.Radius = fovSize
        FOVCircle.Color = Settings.FOVColor
        FOVCircle.Thickness = Settings.FOVThickness
        FOVCircle.Filled = Settings.FOVFilled
        FOVCircle.Transparency = Settings.FOVFilled and (1 - Settings.FOVTransparency / 100) or 1
        FOVCircle.Visible = Settings.ShowFOV and AimAssistEnabled
    end
    
    CreateFOVCircles()
    
    -- Input Detection for Sticky Aim
    UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            StickyAimActive = true
            
            -- Lock onto target when sticky aim is activated
            if Settings.StickyAim and AimAssistEnabled and not LockedTarget then
                local target = GetBestTarget()
                if target then
                    LockedTarget = target
                end
            end
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            StickyAimActive = false
            
            -- Unlock target when sticky aim is deactivated
            if Settings.StickyAim then
                LockedTarget = nil
            end
        end
    end)
    
    -- Main Loop
    local lastFrame = tick()
    RunService.RenderStepped:Connect(function()
        local currentTime = tick()
        local deltaTime = currentTime - lastFrame
        lastFrame = currentTime
        
        UpdateFOVCircles()
        
        if not AimAssistEnabled or not AimAssistActive then
            CurrentTarget = nil
            return
        end
        
        -- Sticky Aim Logic: Use locked target if valid, otherwise get new target
        if Settings.StickyAim and LockedTarget and IsLockedTargetValid() then
            CurrentTarget = LockedTarget
        else
            -- If sticky aim is on but locked target is invalid, clear it
            if Settings.StickyAim and LockedTarget then
                LockedTarget = nil
            end
            CurrentTarget = GetBestTarget()
        end
        
        if CurrentTarget then
            AimAt(CurrentTarget, deltaTime)
        end
    end)
    
    -- UI Creation
    local AimAssistSection = LegitTab:Section({Name = "Aim Assist", Side = 1})
    
    AimAssistSection:Toggle({Name = "Enabled", Flag = "LegitAim_Enabled", Default = false, Callback = function(Value)
        Settings.Enabled = Value
        AimAssistEnabled = Value
    end}):Keybind({Name = "Hotkey", Flag = "LegitAim_Hotkey", Default = Enum.KeyCode.E, Mode = "Hold", Callback = function(Value)
        AimAssistActive = Value
    end})
    
    AimAssistSection:Slider({Name = "Smoothness", Min = 0, Max = 150, Default = 8, Decimals = 0.1, Flag = "LegitAim_Smoothness", Callback = function(Value)
        Settings.Smoothness = Value
    end})
    
    AimAssistSection:Dropdown({Name = "Smoothing Type", Flag = "LegitAim_SmoothType", Default = "Linear", Items = {"Linear", "Exponential", "Sine"}, Callback = function(Value)
        Settings.SmoothingType = Value
    end})
    
    AimAssistSection:Dropdown({Name = "Hit Part", Flag = "LegitAim_HitPart", Default = "Head", Items = {"Head", "Neck", "Upper Chest", "Chest", "Lower Chest", "Stomach", "Pelvis", "Closest Part"}, Callback = function(Value)
        Settings.HitPart = Value
    end})
    
    AimAssistSection:Dropdown({Name = "Target Priority", Flag = "LegitAim_Priority", Default = "Closest to Crosshair", Items = {"Closest to Crosshair", "Closest Distance", "Lowest Health"}, Callback = function(Value)
        Settings.TargetPriority = Value
    end})
    
    local FOVSection = LegitTab:Section({Name = "Field of View", Side = 1})
    
    FOVSection:Toggle({Name = "Show FOV", Flag = "LegitAim_ShowFOV", Default = false, Callback = function(Value) Settings.ShowFOV = Value end}):Colorpicker({Name = "Color", Flag = "LegitAim_FOVColor", Default = Color3.fromRGB(255, 255, 255), Callback = function(Value) Settings.FOVColor = Value end})
    
    FOVSection:Toggle({Name = "Custom Outline", Flag = "LegitAim_CustomOutline", Default = true}):Colorpicker({Name = "Color", Flag = "LegitAim_OutlineColor", Default = Color3.fromRGB(0, 0, 0), Callback = function(Value) Settings.FOVOutlineColor = Value end})
    
    FOVSection:Slider({Name = "FOV Size", Min = 20, Max = 400, Default = 100, Suffix = "px", Decimals = 0.1, Flag = "LegitAim_FOVSize", Callback = function(Value)
        Settings.FOVSize = Value
    end})
    
    FOVSection:Slider({Name = "FOV Thickness", Min = 1, Max = 5, Default = 2, Decimals = 0.1, Flag = "LegitAim_FOVThickness", Callback = function(Value)
        Settings.FOVThickness = Value
    end})
    
    FOVSection:Slider({Name = "Outline Thickness", Min = 1, Max = 8, Default = 3, Decimals = 0.1, Flag = "LegitAim_OutlineThickness", Callback = function(Value)
        Settings.FOVOutlineThickness = Value
    end})
    
    FOVSection:Toggle({Name = "Filled Circle", Flag = "LegitAim_FOVFilled", Default = true, Callback = function(Value)
        Settings.FOVFilled = Value
    end})
    
    FOVSection:Slider({Name = "Fill Transparency", Min = 0, Max = 100, Default = 85, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_FOVTrans", Callback = function(Value)
        Settings.FOVTransparency = Value
    end})
    
    FOVSection:Toggle({Name = "Dynamic FOV", Flag = "LegitAim_DynamicFOV", Default = false, Callback = function(Value)
        Settings.DynamicFOV = Value
    end})
    
    FOVSection:Slider({Name = "Dynamic Intensity", Min = 10, Max = 100, Default = 50, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_DynamicIntensity", Callback = function(Value)
        Settings.DynamicFOVIntensity = Value
    end})
    
    local ChecksSection = LegitTab:Section({Name = "Target Checks", Side = 2})
    
    ChecksSection:Toggle({Name = "Team Check", Flag = "LegitAim_TeamCheck", Default = true, Callback = function(Value)
        Settings.TeamCheck = Value
    end})
    
    ChecksSection:Toggle({Name = "Visible Check", Flag = "LegitAim_VisibleCheck", Default = true, Callback = function(Value)
        Settings.VisibleCheck = Value
    end})
    
    ChecksSection:Toggle({Name = "Alive Check", Flag = "LegitAim_AliveCheck", Default = true, Callback = function(Value)
        Settings.AliveCheck = Value
    end})
    
    ChecksSection:Toggle({Name = "ForceField Check", Flag = "LegitAim_FFCheck", Default = true, Callback = function(Value)
        Settings.ForceFieldCheck = Value
    end})
    
    ChecksSection:Toggle({Name = "Distance Check", Flag = "LegitAim_DistCheck", Default = false, Callback = function(Value)
        Settings.DistanceCheck = Value
    end})
    
    ChecksSection:Slider({Name = "Max Distance", Min = 100, Max = 1000, Default = 500, Suffix = " studs", Decimals = 0.1, Flag = "LegitAim_MaxDist", Callback = function(Value)
        Settings.MaxDistance = Value
    end})
    
    local AdvancedSection = LegitTab:Section({Name = "Advanced", Side = 2})
    
    AdvancedSection:Toggle({Name = "Sticky Aim (Lock Target)", Flag = "LegitAim_Sticky", Default = false, Callback = function(Value)
        Settings.StickyAim = Value
        -- Clear locked target when toggling off
        if not Value then
            LockedTarget = nil
        end
    end})
    
    AdvancedSection:Slider({Name = "Shake Reduction", Min = 0, Max = 100, Default = 0, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_Shake", Callback = function(Value)
        Settings.ShakeReduction = Value
    end})
    
    AdvancedSection:Toggle({Name = "Aim Acceleration", Flag = "LegitAim_Accel", Default = false, Callback = function(Value)
        Settings.AimAcceleration = Value
    end})
    
    AdvancedSection:Slider({Name = "Acceleration Speed", Min = 0, Max = 50, Default = 15, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_AccelSpeed", Callback = function(Value)
        Settings.AccelerationSpeed = Value
    end})
    
    AdvancedSection:Slider({Name = "Max Aim Speed", Min = 10, Max = 100, Default = 100, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_MaxSpeed", Callback = function(Value)
        Settings.MaxAimSpeed = Value
    end})
    
    AdvancedSection:Slider({Name = "Aim Deadzone", Min = 0, Max = 50, Default = 5, Suffix = "px", Decimals = 0.1, Flag = "LegitAim_Deadzone", Callback = function(Value)
        Settings.AimDeadzone = Value
    end})
    
    local HumanizationSection = LegitTab:Section({Name = "Humanization", Side = 2})
    
    HumanizationSection:Slider({Name = "Reaction Time", Min = 0, Max = 300, Default = 50, Suffix = "ms", Decimals = 0.1, Flag = "LegitAim_Reaction", Callback = function(Value)
        Settings.ReactionTime = Value
    end})
    
    HumanizationSection:Slider({Name = "Miss Chance", Min = 0, Max = 25, Default = 0, Suffix = "%", Decimals = 0.1, Flag = "LegitAim_Miss", Callback = function(Value)
        Settings.MissChance = Value
    end})
    
    HumanizationSection:Toggle({Name = "Natural Sway", Flag = "LegitAim_Sway", Default = false, Callback = function(Value)
        Settings.NaturalSway = Value
    end})
    
    HumanizationSection:Slider({Name = "Sway Intensity", Min = 0, Max = 10, Default = 2, Decimals = 0.1, Flag = "LegitAim_SwayIntensity", Callback = function(Value)
        Settings.SwayIntensity = Value
    end})
    

end






































local VisualsTab = Window:Page({Name = "Visuals", Columns = 2, Subtabs = false})

































do -- Misc Tab
    local MiscTab = Window:Page({Name = "Misc", Columns = 2, Subtabs = false})

    local RunService       = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Players          = game:GetService("Players")
    local LocalPlayer      = Players.LocalPlayer

    --------------------------------------------------------------------
    -- Variables
    --------------------------------------------------------------------
    local SpeedEnabled = false;      local SpeedConnection = nil;      local OriginalWalkSpeed = 16
    local FlyEnabled   = false;      local FlyConnection   = nil;      local FlyBV = nil; local FlyBG = nil
    local InfiniteJumpEnabled = false; local InfiniteJumpConnection = nil
    local NoClipEnabled = false;     local NoClipConnection = nil
    local FOVEnabled   = false;      local OriginalFOV = 70
    local AntiFlingEnabled = false;  local AntiFlingConnection = nil
    local ClickTPEnabled = false;    local ClickTPConnection = nil

    --------------------------------------------------------------------
    -- Speed
    --------------------------------------------------------------------
    local function EnableSpeed()
        local Char = LocalPlayer.Character
        if not Char then return end
        local Hum  = Char:FindFirstChildOfClass("Humanoid")
        local HRP  = Char:FindFirstChild("HumanoidRootPart")
        if not Hum or not HRP then return end

        local Amount = Library.Flags["Speed_Amount"] or 16
        local Mode   = Library.Flags["Speed_Mode"]   or "Velocity"

        if Mode == "WalkSpeed" then
            OriginalWalkSpeed = Hum.WalkSpeed
            Hum.WalkSpeed = Amount
            return
        end

        if SpeedConnection then SpeedConnection:Disconnect() end

        SpeedConnection = RunService.RenderStepped:Connect(function()
            if not SpeedEnabled then return end
            local C = LocalPlayer.Character
            if not C then return end
            local H = C:FindFirstChildOfClass("Humanoid")
            local R = C:FindFirstChild("HumanoidRootPart")
            if not H or not R then return end
            if H.MoveDirection.Magnitude == 0 then return end

            if Mode == "CFrame" then
                local Speed = (Library.Flags["Speed_Amount"] or 16) / 16
                R.CFrame = R.CFrame + (H.MoveDirection * Speed)
            else -- Velocity
                local Speed = Library.Flags["Speed_Amount"] or 16
                R.Velocity = Vector3.new(H.MoveDirection.X * Speed, R.Velocity.Y, H.MoveDirection.Z * Speed)
            end
        end)
    end

    local function DisableSpeed()
        if SpeedConnection then SpeedConnection:Disconnect(); SpeedConnection = nil end
        local Char = LocalPlayer.Character
        if Char then
            local Hum = Char:FindFirstChildOfClass("Humanoid")
            if Hum then Hum.WalkSpeed = OriginalWalkSpeed end
        end
    end

    --------------------------------------------------------------------
    -- Fly
    --------------------------------------------------------------------
    local function EnableFly()
        local Char = LocalPlayer.Character
        if not Char then return end
        local HRP = Char:FindFirstChild("HumanoidRootPart")
        if not HRP then return end

        if FlyConnection then FlyConnection:Disconnect(); FlyConnection = nil end
        if FlyBV and FlyBV.Parent then FlyBV:Destroy(); FlyBV = nil end
        if FlyBG and FlyBG.Parent then FlyBG:Destroy(); FlyBG = nil end

        FlyBV = Instance.new("BodyVelocity")
        FlyBV.Velocity = Vector3.new()
        FlyBV.MaxForce = Vector3.new(9e9,9e9,9e9)
        FlyBV.Parent   = HRP

        FlyBG = Instance.new("BodyGyro")
        FlyBG.MaxTorque = Vector3.new(9e9,9e9,9e9)
        FlyBG.CFrame    = HRP.CFrame
        FlyBG.Parent    = HRP

        FlyConnection = RunService.RenderStepped:Connect(function()
            if not FlyEnabled or not FlyBV or not FlyBV.Parent or not FlyBG or not FlyBG.Parent then return end
            local C = LocalPlayer.Character
            if not C then return end
            local R = C:FindFirstChild("HumanoidRootPart")
            if not R then return end

            local Cam   = workspace.CurrentCamera
            local Speed = Library.Flags["Fly_Speed"] or 50

            FlyBG.CFrame = Cam.CFrame

            local Dir = Vector3.new()
            if UserInputService:IsKeyDown(Enum.KeyCode.W)      then Dir += Cam.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.S)      then Dir -= Cam.CFrame.LookVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.A)      then Dir -= Cam.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.D)      then Dir += Cam.CFrame.RightVector end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space)  then Dir += Vector3.new(0,1,0) end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then Dir -= Vector3.new(0,1,0) end

            FlyBV.Velocity = Dir * Speed
        end)
    end

    local function DisableFly()
        if FlyConnection then FlyConnection:Disconnect(); FlyConnection = nil end
        if FlyBV and FlyBV.Parent then FlyBV:Destroy(); FlyBV = nil end
        if FlyBG and FlyBG.Parent then FlyBG:Destroy(); FlyBG = nil end
    end

    --------------------------------------------------------------------
    -- Anti-Fling
    --------------------------------------------------------------------
    local function ToggleAntiFling(on)
        if on then
            AntiFlingConnection = RunService.Stepped:Connect(function()
                if not AntiFlingEnabled then return end
                local C = LocalPlayer.Character
                if not C then return end
                local R = C:FindFirstChild("HumanoidRootPart")
                if not R then return end

                for _, v in pairs(C:GetDescendants()) do
                    if v:IsA("BodyVelocity") or v:IsA("BodyPosition") or v:IsA("BodyAngularVelocity") then
                        if v.Parent ~= R or (v == FlyBV or v == FlyBG) then v:Destroy() end
                    end
                end

                R.AssemblyLinearVelocity = Vector3.new(0, R.AssemblyLinearVelocity.Y, 0)
            end)
        else
            if AntiFlingConnection then AntiFlingConnection:Disconnect(); AntiFlingConnection = nil end
        end
    end

    --------------------------------------------------------------------
    -- Click TP (Bonus Feature!)
    --------------------------------------------------------------------
    local function EnableClickTP()
        if ClickTPConnection then ClickTPConnection:Disconnect() end
        ClickTPConnection = UserInputService.InputBegan:Connect(function(input)
            if not ClickTPEnabled or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
            local mouse = LocalPlayer:GetMouse()
            local targetPos = mouse.Hit.p
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.CFrame = CFrame.new(targetPos + Vector3.new(0, 5, 0))
            end
        end)
    end

    local function DisableClickTP()
        if ClickTPConnection then ClickTPConnection:Disconnect(); ClickTPConnection = nil end
    end

    --------------------------------------------------------------------
    -- Infinite Jump / No Clip / FOV
    --------------------------------------------------------------------
    local function ToggleInfiniteJump(on)
        if on then
            InfiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
                if not InfiniteJumpEnabled then return end
                local C = LocalPlayer.Character
                if C then
                    local H = C:FindFirstChildOfClass("Humanoid")
                    if H then H:ChangeState(Enum.HumanoidStateType.Jumping) end
                end
            end)
        else
            if InfiniteJumpConnection then InfiniteJumpConnection:Disconnect(); InfiniteJumpConnection = nil end
        end
    end

    local function ToggleNoClip(on)
        if on then
            NoClipConnection = RunService.Stepped:Connect(function()
                if not NoClipEnabled then return end
                local C = LocalPlayer.Character
                if C then
                    for _, p in pairs(C:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = false end
                    end
                end
            end)
        else
            if NoClipConnection then NoClipConnection:Disconnect(); NoClipConnection = nil end
            local C = LocalPlayer.Character
            if C then
                for _, p in pairs(C:GetDescendants()) do
                    if p:IsA("BasePart") and p.Name ~= "HumanoidRootPart" then p.CanCollide = true end
                end
            end
        end
    end

    local function SetFOV(v)
        local cam = workspace.CurrentCamera
        if cam then cam.FieldOfView = v end
    end

    --------------------------------------------------------------------
    -- UI
    --------------------------------------------------------------------
    local MovementSection = MiscTab:Section({Name = "Movement", Side = 1})

    -- Speed
    MovementSection:Toggle({
        Name = "Speed", Flag = "Speed_Enabled", Default = false,
        Callback = function(v)
            SpeedEnabled = v
            if v then EnableSpeed() else DisableSpeed() end
        end
    }):Keybind({
        Flag = "Speed_Keybind", Default = Enum.KeyCode.X,
        Callback = function(pressed)
            if not Library.Flags["Speed_Enabled"] then return end
            SpeedEnabled = pressed
            if pressed then EnableSpeed() else DisableSpeed() end
        end,
        Mode = "Hold"
    })

    MovementSection:Slider({Name = "Speed Amount", Min = 16, Max = 200, Default = 50, Flag = "Speed_Amount",
        Callback = function() if SpeedEnabled then DisableSpeed() EnableSpeed() end end})

    MovementSection:Dropdown({Name = "Speed Mode", Flag = "Speed_Mode", Default = "CFrame",
        Items = {"WalkSpeed","CFrame","Velocity"},
        Callback = function() if SpeedEnabled then DisableSpeed() EnableSpeed() end end})

    -- Fly
    MovementSection:Toggle({
        Name = "Fly", Flag = "Fly_Enabled", Default = false,
        Callback = function(v)
            FlyEnabled = v
            if v then EnableFly() else DisableFly() end
        end
    }):Keybind({
        Flag = "Fly_Keybind", Default = Enum.KeyCode.F,
        Callback = function(pressed)
            if not Library.Flags["Fly_Enabled"] then return end
            FlyEnabled = pressed
            if pressed then EnableFly() else DisableFly() end
        end,
        Mode = "Hold"
    })

    MovementSection:Slider({Name = "Fly Speed", Min = 10, Max = 200, Default = 50, Flag = "Fly_Speed"})

    -- Click TP (Bonus!)
    MovementSection:Toggle({
        Name = "Click TP", Flag = "Click_TP", Default = false,
        Callback = function(v)
            ClickTPEnabled = v
            if v then EnableClickTP() else DisableClickTP() end
        end
    }):Keybind({Flag = "Click_TP_Key", Default = Enum.KeyCode.LeftAlt})

    -- Anti Fling
    MovementSection:Toggle({
        Name = "Anti Fling", Flag = "Anti_Fling", Default = false,
        Callback = function(v)
            AntiFlingEnabled = v
            ToggleAntiFling(v)
        end
    })

    -- Infinite Jump
    MovementSection:Toggle({
        Name = "Infinite Jump", Flag = "Infinite_Jump", Default = false,
        Callback = function(v)
            InfiniteJumpEnabled = v
            ToggleInfiniteJump(v)
        end
    })

    -- No Clip
    MovementSection:Toggle({
        Name = "No Clip", Flag = "No_Clip", Default = false,
        Callback = function(v)
            NoClipEnabled = v
            ToggleNoClip(v)
        end
    }):Keybind({Flag = "No_Clip_Keybind", Default = Enum.KeyCode.C})

    -- Jump Power
    MovementSection:Slider({
        Name = "Jump Power", Min = 50, Max = 200, Default = 50, Flag = "Jump_Power",
        Callback = function(v)
            local C = LocalPlayer.Character
            if C then
                local H = C:FindFirstChildOfClass("Humanoid")
                if H then H.JumpPower = v end
            end
        end
    })

    --------------------------------------------------------------------
    -- Character Section
    --------------------------------------------------------------------
    local CharacterSection = MiscTab:Section({Name = "Character", Side = 1})

    CharacterSection:Toggle({
        Name = "FOV Changer", Flag = "FOV_Enabled", Default = false,
        Callback = function(v)
            FOVEnabled = v
            SetFOV(v and (Library.Flags["FOV_Amount"] or 70) or OriginalFOV)
        end
    })

    CharacterSection:Slider({
        Name = "FOV Amount", Min = 70, Max = 120, Default = 90, Suffix = " degrees",
        Flag = "FOV_Amount",
        Callback = function(v) if FOVEnabled then SetFOV(v) end end
    })

    CharacterSection:Button({Name = "Remove Accessories", Callback = function()
        local C = LocalPlayer.Character
        if C then for _, a in pairs(C:GetChildren()) do if a:IsA("Accessory") then a:Destroy() end end end
    end})

    CharacterSection:Button({Name = "Reset Character", Callback = function()
        local C = LocalPlayer.Character
        if C then local H = C:FindFirstChildOfClass("Humanoid") if H then H.Health = 0 end end
    end})

    --------------------------------------------------------------------
    -- Utility Section (Now Only Anti-AFK)
    --------------------------------------------------------------------
    local UtilitySection = MiscTab:Section({Name = "Utility", Side = 2})

    UtilitySection:Toggle({
        Name = "Anti AFK", Flag = "Anti_AFK", Default = false,
        Callback = function(v)
            if v then
                local VU = game:GetService("VirtualUser")
                LocalPlayer.Idled:Connect(function()
                    if Library.Flags["Anti_AFK"] then
                        VU:CaptureController()
                        VU:ClickButton2(Vector2.new())
                    end
                end)
            end
        end
    })

    --------------------------------------------------------------------
    -- Game Section
    --------------------------------------------------------------------
    local GameSection = MiscTab:Section({Name = "Game", Side = 2})

    GameSection:Button({Name = "Rejoin Server", Callback = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    end})

    GameSection:Button({Name = "Server Hop", Callback = function()
        local TS = game:GetService("TeleportService")
        local HS = game:GetService("HttpService")
        local data = HS:JSONDecode(game:HttpGet(
            "https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"))
        if data and data.data then
            for _, srv in pairs(data.data) do
                if srv.id ~= game.JobId and srv.playing < srv.maxPlayers then
                    TS:TeleportToPlaceInstance(game.PlaceId, srv.id, LocalPlayer); break
                end
            end
        end
    end})

    --------------------------------------------------------------------
    -- Respawn Handler
    --------------------------------------------------------------------
    LocalPlayer.CharacterAdded:Connect(function(Char)
        Char:WaitForChild("HumanoidRootPart")
        task.wait(0.15)

        if Library.Flags["Jump_Power"] and Library.Flags["Jump_Power"] ~= 50 then
            local H = Char:FindFirstChildOfClass("Humanoid")
            if H then H.JumpPower = Library.Flags["Jump_Power"] end
        end

        if SpeedEnabled then task.wait(0.1); EnableSpeed() end
        if FlyEnabled then
            task.wait(0.1); DisableFly()
            task.wait(0.15); EnableFly()
        end
        if AntiFlingEnabled then
            task.wait(0.05); ToggleAntiFling(false); ToggleAntiFling(true)
        end
        if ClickTPEnabled then EnableClickTP() end
        if FOVEnabled then SetFOV(Library.Flags["FOV_Amount"] or 70) end
    end)
end

















local SettingsTab = Window:Page({Name = "Settings", Columns = 2, Subtabs = false})






























































do -- Visuals Tab
    -- ESP Storage
    local ESPObjects = {}
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Camera = workspace.CurrentCamera

    -- Local Player Visuals
    local ChinaHat = nil
    local OriginalMaterials = {}

    -- ESP Functions
    local function CreateDrawing(Type, Properties)
        local Drawing = Drawing.new(Type)
        for Property, Value in pairs(Properties) do
            Drawing[Property] = Value
        end
        return Drawing
    end

    local function RemoveESP(Player)
        if ESPObjects[Player] then
            for _, Drawing in pairs(ESPObjects[Player]) do
                if Drawing then
                    if typeof(Drawing) == "Instance" then
                        Drawing:Destroy()
                    elseif Drawing.Remove then
                        pcall(function() Drawing:Remove() end)
                    end
                end
            end
            -- Clean up skeleton lines
            if ESPObjects[Player].SkeletonLines then
                for _, line in pairs(ESPObjects[Player].SkeletonLines) do
                    if line and line.Remove then
                        pcall(function() line:Remove() end)
                    end
                end
            end
            ESPObjects[Player] = nil
        end
    end

    local function CreateESP(Player)
        if Player == LocalPlayer then return end
        
        ESPObjects[Player] = {
            -- Bounding Box Lines (12 edges of a 3D box)
            TopFrontLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            TopBackLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            TopLeftLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            TopRightLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            
            BottomFrontLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            BottomBackLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            BottomLeftLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            BottomRightLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            
            FrontLeftLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            FrontRightLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            BackLeftLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            BackRightLine = CreateDrawing("Line", {Thickness = 1, Visible = false, ZIndex = 2}),
            
            -- 2D Box with Outline and Fill
            BoxOutline = CreateDrawing("Square", {
                Thickness = 3,
                Filled = false,
                Color = Color3.fromRGB(0, 0, 0),
                Visible = false,
                ZIndex = 1
            }),
            Box = CreateDrawing("Square", {
                Thickness = 1,
                Filled = false,
                Visible = false,
                ZIndex = 2
            }),
            BoxFill = CreateDrawing("Square", {
                Thickness = 1,
                Filled = true,
                Visible = false,
                Transparency = 0.3,
                ZIndex = 1
            }),
            HealthBar = CreateDrawing("Square", {
                Thickness = 1,
                Filled = true,
                Visible = false,
                ZIndex = 1
            }),
            HealthBarOutline = CreateDrawing("Square", {
                Thickness = 1,
                Filled = false,
                Color = Color3.fromRGB(0, 0, 0),
                Visible = false,
                ZIndex = 1
            }),
            Name = CreateDrawing("Text", {
                Center = true,
                Outline = true,
                Size = 13,
                Font = 2,
                Visible = false,
                ZIndex = 3
            }),
            Distance = CreateDrawing("Text", {
                Center = true,
                Outline = true,
                Size = 13,
                Font = 2,
                Visible = false,
                ZIndex = 3
            }),
            Weapon = CreateDrawing("Text", {
                Center = true,
                Outline = true,
                Size = 13,
                Font = 2,
                Visible = false,
                ZIndex = 3
            }),
            Tracer = CreateDrawing("Line", {
                Thickness = 1,
                Visible = false,
                ZIndex = 1
            }),
            -- Offscreen Arrow
            OffscreenArrow = CreateDrawing("Triangle", {
                Thickness = 1,
                Filled = true,
                Visible = false,
                ZIndex = 3
            }),
            -- Skeleton ESP Lines
            SkeletonLines = {}
        }
        
        -- Create skeleton lines
        local skeletonPairs = {
            "Head-UpperTorso", "UpperTorso-LowerTorso",
            "UpperTorso-LeftUpperArm", "LeftUpperArm-LeftLowerArm", "LeftLowerArm-LeftHand",
            "UpperTorso-RightUpperArm", "RightUpperArm-RightLowerArm", "RightLowerArm-RightHand",
            "LowerTorso-LeftUpperLeg", "LeftUpperLeg-LeftLowerLeg", "LeftLowerLeg-LeftFoot",
            "LowerTorso-RightUpperLeg", "RightUpperLeg-RightLowerLeg", "RightLowerLeg-RightFoot"
        }
        
        for _, pair in ipairs(skeletonPairs) do
            ESPObjects[Player].SkeletonLines[pair] = CreateDrawing("Line", {
                Thickness = 1,
                Visible = false,
                ZIndex = 2
            })
        end
    end

    local function GetHealth(Character)
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            return Humanoid.Health, Humanoid.MaxHealth
        end
        return 100, 100
    end

    local function GetWeapon(Player)
        local Character = Player.Character
        if Character then
            local Tool = Character:FindFirstChildOfClass("Tool")
            if Tool then
                return Tool.Name
            end
        end
        return "None"
    end

    local function IsVisible(Character)
        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        if not HumanoidRootPart then return false end
        
        local Origin = Camera.CFrame.Position
        local Direction = (HumanoidRootPart.Position - Origin).Unit * (HumanoidRootPart.Position - Origin).Magnitude
        
        local Ray = Ray.new(Origin, Direction)
        local Hit, Position = workspace:FindPartOnRayWithIgnoreList(Ray, {LocalPlayer.Character, Character})
        
        return Hit == nil or Hit:IsDescendantOf(Character)
    end

    local function GetBoundingBox(Character)
        local min = Vector3.new(math.huge, math.huge, math.huge)
        local max = Vector3.new(-math.huge, -math.huge, -math.huge)
        
        for _, part in pairs(Character:GetDescendants()) do
            if part:IsA("BasePart") then
                local cf = part.CFrame
                local size = part.Size
                local corners = {
                    cf * CFrame.new(size.X/2, size.Y/2, size.Z/2),
                    cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2),
                    cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2),
                    cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2),
                    cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2),
                    cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),
                    cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2),
                    cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2)
                }
                
                for _, corner in pairs(corners) do
                    min = Vector3.new(
                        math.min(min.X, corner.X),
                        math.min(min.Y, corner.Y),
                        math.min(min.Z, corner.Z)
                    )
                    max = Vector3.new(
                        math.max(max.X, corner.X),
                        math.max(max.Y, corner.Y),
                        math.max(max.Z, corner.Z)
                    )
                end
            end
        end
        
        return min, max
    end

    local function DrawOffscreenArrow(Player, RootPosition)
        local Arrow = ESPObjects[Player].OffscreenArrow
        local ScreenSize = Camera.ViewportSize
        local Center = Vector2.new(ScreenSize.X / 2, ScreenSize.Y / 2)
        
        local _, OnScreen = Camera:WorldToViewportPoint(RootPosition)
        
        if not OnScreen then
            local ViewportPoint = Camera:WorldToViewportPoint(RootPosition)
            local Direction = (Vector2.new(ViewportPoint.X, ViewportPoint.Y) - Center).Unit
            
            -- Calculate arrow position at screen edge
            local Margin = Library.Flags["ESP_Offscreen_Distance"] or 50
            local MaxX = ScreenSize.X - Margin
            local MaxY = ScreenSize.Y - Margin
            
            local ArrowPos = Center + Direction * math.min(
                math.abs((Direction.X > 0 and MaxX or Margin) - Center.X) / math.abs(Direction.X),
                math.abs((Direction.Y > 0 and MaxY or Margin) - Center.Y) / math.abs(Direction.Y)
            ) * Direction
            
            -- Calculate rotation angle
            local Angle = math.atan2(Direction.Y, Direction.X)
            
            -- Create triangle points for arrow
            local ArrowSize = Library.Flags["ESP_Offscreen_Size"] or 15
            local Point1 = Vector2.new(
                ArrowPos.X + math.cos(Angle) * ArrowSize,
                ArrowPos.Y + math.sin(Angle) * ArrowSize
            )
            local Point2 = Vector2.new(
                ArrowPos.X + math.cos(Angle + 2.5) * ArrowSize * 0.6,
                ArrowPos.Y + math.sin(Angle + 2.5) * ArrowSize * 0.6
            )
            local Point3 = Vector2.new(
                ArrowPos.X + math.cos(Angle - 2.5) * ArrowSize * 0.6,
                ArrowPos.Y + math.sin(Angle - 2.5) * ArrowSize * 0.6
            )
            
            Arrow.PointA = Point1
            Arrow.PointB = Point2
            Arrow.PointC = Point3
            Arrow.Color = Library.Flags["ESP_Offscreen_Color"].Color
            Arrow.Transparency = 1 - (Library.Flags["ESP_Offscreen_Transparency"] or 0)
            Arrow.Visible = true
        else
            Arrow.Visible = false
        end
    end

    local function DrawSkeleton(Player, Character)
        if not Library.Flags["ESP_Skeleton"] then
            for _, line in pairs(ESPObjects[Player].SkeletonLines) do
                line.Visible = false
            end
            return
        end
        
        local skeletonConnections = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LeftLowerLeg", "LeftFoot"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
            {"RightLowerLeg", "RightFoot"}
        }
        
        for _, connection in ipairs(skeletonConnections) do
            local part1 = Character:FindFirstChild(connection[1])
            local part2 = Character:FindFirstChild(connection[2])
            local lineName = connection[1] .. "-" .. connection[2]
            local line = ESPObjects[Player].SkeletonLines[lineName]
            
            if part1 and part2 and line then
                local pos1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)
                local pos2, onScreen2 = Camera:WorldToViewportPoint(part2.Position)
                
                if onScreen1 and onScreen2 then
                    line.From = Vector2.new(pos1.X, pos1.Y)
                    line.To = Vector2.new(pos2.X, pos2.Y)
                    line.Color = Library.Flags["ESP_Skeleton_Color"].Color
                    line.Visible = true
                else
                    line.Visible = false
                end
            elseif line then
                line.Visible = false
            end
        end
    end

    local function CreateChinaHat()
        if ChinaHat then ChinaHat:Destroy() end
        
        local Character = LocalPlayer.Character
        if not Character then return end
        local Head = Character:FindFirstChild("Head")
        if not Head then return end
        
        ChinaHat = Instance.new("Part")
        local HatSize = Library.Flags["China_Hat_Size"] or 4
        ChinaHat.Size = Vector3.new(HatSize, 0.2, HatSize)
        ChinaHat.Material = Library.Flags["China_Hat_Material"] == "Neon" and Enum.Material.Neon or Enum.Material.ForceField
        ChinaHat.BrickColor = Library.Flags["China_Hat_Color"] and BrickColor.new(Library.Flags["China_Hat_Color"].Color) or BrickColor.new("Bright red")
        ChinaHat.CanCollide = false
        ChinaHat.Anchored = false
        ChinaHat.Name = "ChinaHat"
        ChinaHat.Transparency = Library.Flags["China_Hat_Transparency"] or 0
        
        local Mesh = Instance.new("SpecialMesh", ChinaHat)
        Mesh.MeshType = Enum.MeshType.FileMesh
        Mesh.MeshId = "rbxassetid://1778999"
        Mesh.Scale = Vector3.new(HatSize, 1, HatSize)
        
        local Weld = Instance.new("Weld", ChinaHat)
        Weld.Part0 = Head
        Weld.Part1 = ChinaHat
        local HatHeight = Library.Flags["China_Hat_Height"] or 0.7
        Weld.C0 = CFrame.new(0, HatHeight, 0)
        
        -- Add spinning effect if enabled
        if Library.Flags["China_Hat_Spin"] then
            local SpinSpeed = Library.Flags["China_Hat_Spin_Speed"] or 5
            local SpinConnection
            SpinConnection = RunService.RenderStepped:Connect(function(dt)
                if ChinaHat and ChinaHat.Parent then
                    Weld.C0 = Weld.C0 * CFrame.Angles(0, math.rad(SpinSpeed * dt * 60), 0)
                else
                    if SpinConnection then
                        SpinConnection:Disconnect()
                    end
                end
            end)
        end
        
        ChinaHat.Parent = Character
    end

    local function RemoveChinaHat()
        if ChinaHat then
            ChinaHat:Destroy()
            ChinaHat = nil
        end
    end

    local function ChangeMaterial(Material)
        local Character = LocalPlayer.Character
        if not Character then return end
        
        for _, part in pairs(Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                if not OriginalMaterials[part] then
                    OriginalMaterials[part] = part.Material
                end
                
                if Material == "Foil" then
                    part.Material = Enum.Material.Foil
                elseif Material == "ForceField" then
                    part.Material = Enum.Material.ForceField
                elseif Material == "Default" then
                    part.Material = OriginalMaterials[part] or Enum.Material.Plastic
                end
            end
        end
    end

    local function UpdateESP()
        if not Library.Flags["ESP_Enabled"] then return end

        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer and Player.Character then
                local Character = Player.Character
                local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
                local Head = Character:FindFirstChild("Head")
                local Humanoid = Character:FindFirstChildOfClass("Humanoid")

                if not ESPObjects[Player] then
                    CreateESP(Player)
                end

                if HumanoidRootPart and Head and Humanoid and Humanoid.Health > 0 then
                    local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                    
                    -- Team Check
                    if Library.Flags["ESP_Team_Check"] and Player.Team == LocalPlayer.Team then
                        RemoveESP(Player)
                        continue
                    end

                    -- Distance Check
                    if Library.Flags["ESP_Max_Distance_Check"] and Distance > Library.Flags["ESP_Max_Distance"] then
                        for _, Drawing in pairs(ESPObjects[Player]) do
                            if type(Drawing) == "userdata" then
                                Drawing.Visible = false
                            end
                        end
                        for _, line in pairs(ESPObjects[Player].SkeletonLines) do
                            line.Visible = false
                        end
                        continue
                    end

                    local Vector, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart.Position)
                    local Visible = IsVisible(Character)
                    
                    -- Draw Offscreen Arrows
                    if Library.Flags["ESP_Offscreen"] then
                        DrawOffscreenArrow(Player, HumanoidRootPart.Position)
                    else
                        ESPObjects[Player].OffscreenArrow.Visible = false
                    end
                    
                    -- Draw Skeleton
                    DrawSkeleton(Player, Character)
                    
                    if OnScreen then
                        -- Bounding Box ESP
                        if Library.Flags["ESP_Box"] then
                            if Library.Flags["ESP_Box_Type"] == "3D" then
                                -- 3D Bounding Box
                                local min, max = GetBoundingBox(Character)
                                
                                -- 8 corners of the bounding box
                                local corners = {
                                    Vector3.new(min.X, max.Y, min.Z), -- Top Front Left
                                    Vector3.new(max.X, max.Y, min.Z), -- Top Front Right
                                    Vector3.new(min.X, max.Y, max.Z), -- Top Back Left
                                    Vector3.new(max.X, max.Y, max.Z), -- Top Back Right
                                    Vector3.new(min.X, min.Y, min.Z), -- Bottom Front Left
                                    Vector3.new(max.X, min.Y, min.Z), -- Bottom Front Right
                                    Vector3.new(min.X, min.Y, max.Z), -- Bottom Back Left
                                    Vector3.new(max.X, min.Y, max.Z)  -- Bottom Back Right
                                }
                                
                                -- Convert to screen space
                                local screenCorners = {}
                                local allOnScreen = true
                                for i, corner in ipairs(corners) do
                                    local screenPos, onScreen = Camera:WorldToViewportPoint(corner)
                                    screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
                                    if not onScreen then
                                        allOnScreen = false
                                    end
                                end
                                
                                if allOnScreen then
                                    local color = Library.Flags["ESP_Box_Color"].Color
                                    
                                    -- Hide 2D box
                                    ESPObjects[Player].Box.Visible = false
                                    ESPObjects[Player].BoxOutline.Visible = false
                                    ESPObjects[Player].BoxFill.Visible = false
                                    
                                    -- Draw 3D box lines
                                    ESPObjects[Player].TopFrontLine.From = screenCorners[1]
                                    ESPObjects[Player].TopFrontLine.To = screenCorners[2]
                                    ESPObjects[Player].TopFrontLine.Color = color
                                    ESPObjects[Player].TopFrontLine.Visible = true
                                    
                                    ESPObjects[Player].TopBackLine.From = screenCorners[3]
                                    ESPObjects[Player].TopBackLine.To = screenCorners[4]
                                    ESPObjects[Player].TopBackLine.Color = color
                                    ESPObjects[Player].TopBackLine.Visible = true
                                    
                                    ESPObjects[Player].TopLeftLine.From = screenCorners[1]
                                    ESPObjects[Player].TopLeftLine.To = screenCorners[3]
                                    ESPObjects[Player].TopLeftLine.Color = color
                                    ESPObjects[Player].TopLeftLine.Visible = true
                                    
                                    ESPObjects[Player].TopRightLine.From = screenCorners[2]
                                    ESPObjects[Player].TopRightLine.To = screenCorners[4]
                                    ESPObjects[Player].TopRightLine.Color = color
                                    ESPObjects[Player].TopRightLine.Visible = true
                                    
                                    ESPObjects[Player].BottomFrontLine.From = screenCorners[5]
                                    ESPObjects[Player].BottomFrontLine.To = screenCorners[6]
                                    ESPObjects[Player].BottomFrontLine.Color = color
                                    ESPObjects[Player].BottomFrontLine.Visible = true
                                    
                                    ESPObjects[Player].BottomBackLine.From = screenCorners[7]
                                    ESPObjects[Player].BottomBackLine.To = screenCorners[8]
                                    ESPObjects[Player].BottomBackLine.Color = color
                                    ESPObjects[Player].BottomBackLine.Visible = true
                                    
                                    ESPObjects[Player].BottomLeftLine.From = screenCorners[5]
                                    ESPObjects[Player].BottomLeftLine.To = screenCorners[7]
                                    ESPObjects[Player].BottomLeftLine.Color = color
                                    ESPObjects[Player].BottomLeftLine.Visible = true
                                    
                                    ESPObjects[Player].BottomRightLine.From = screenCorners[6]
                                    ESPObjects[Player].BottomRightLine.To = screenCorners[8]
                                    ESPObjects[Player].BottomRightLine.Color = color
                                    ESPObjects[Player].BottomRightLine.Visible = true
                                    
                                    ESPObjects[Player].FrontLeftLine.From = screenCorners[1]
                                    ESPObjects[Player].FrontLeftLine.To = screenCorners[5]
                                    ESPObjects[Player].FrontLeftLine.Color = color
                                    ESPObjects[Player].FrontLeftLine.Visible = true
                                    
                                    ESPObjects[Player].FrontRightLine.From = screenCorners[2]
                                    ESPObjects[Player].FrontRightLine.To = screenCorners[6]
                                    ESPObjects[Player].FrontRightLine.Color = color
                                    ESPObjects[Player].FrontRightLine.Visible = true
                                    
                                    ESPObjects[Player].BackLeftLine.From = screenCorners[3]
                                    ESPObjects[Player].BackLeftLine.To = screenCorners[7]
                                    ESPObjects[Player].BackLeftLine.Color = color
                                    ESPObjects[Player].BackLeftLine.Visible = true
                                    
                                    ESPObjects[Player].BackRightLine.From = screenCorners[4]
                                    ESPObjects[Player].BackRightLine.To = screenCorners[8]
                                    ESPObjects[Player].BackRightLine.Color = color
                                    ESPObjects[Player].BackRightLine.Visible = true
                                else
                                    -- Hide 3D lines if not all on screen
                                    ESPObjects[Player].TopFrontLine.Visible = false
                                    ESPObjects[Player].TopBackLine.Visible = false
                                    ESPObjects[Player].TopLeftLine.Visible = false
                                    ESPObjects[Player].TopRightLine.Visible = false
                                    ESPObjects[Player].BottomFrontLine.Visible = false
                                    ESPObjects[Player].BottomBackLine.Visible = false
                                    ESPObjects[Player].BottomLeftLine.Visible = false
                                    ESPObjects[Player].BottomRightLine.Visible = false
                                    ESPObjects[Player].FrontLeftLine.Visible = false
                                    ESPObjects[Player].FrontRightLine.Visible = false
                                    ESPObjects[Player].BackLeftLine.Visible = false
                                    ESPObjects[Player].BackRightLine.Visible = false
                                end
                            else
                                -- 2D Box with Outline
                                local HeadVector = Camera:WorldToViewportPoint(Head.Position + Vector3.new(0, 0.5, 0))
                                local LegVector = Camera:WorldToViewportPoint(HumanoidRootPart.Position - Vector3.new(0, 3.5, 0))
                                
                                local Height = math.abs(HeadVector.Y - LegVector.Y)
                                local Width = Height / 1.5
                                
                                -- Hide 3D lines
                                ESPObjects[Player].TopFrontLine.Visible = false
                                ESPObjects[Player].TopBackLine.Visible = false
                                ESPObjects[Player].TopLeftLine.Visible = false
                                ESPObjects[Player].TopRightLine.Visible = false
                                ESPObjects[Player].BottomFrontLine.Visible = false
                                ESPObjects[Player].BottomBackLine.Visible = false
                                ESPObjects[Player].BottomLeftLine.Visible = false
                                ESPObjects[Player].BottomRightLine.Visible = false
                                ESPObjects[Player].FrontLeftLine.Visible = false
                                ESPObjects[Player].FrontRightLine.Visible = false
                                ESPObjects[Player].BackLeftLine.Visible = false
                                ESPObjects[Player].BackRightLine.Visible = false
                                
                                -- Box Fill
                                if Library.Flags["ESP_Box_Fill"] then
                                    local BoxFill = ESPObjects[Player].BoxFill
                                    BoxFill.Size = Vector2.new(Width, Height)
                                    BoxFill.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
                                    BoxFill.Color = Library.Flags["ESP_Box_Fill_Color"].Color
                                    BoxFill.Transparency = 1 - Library.Flags["ESP_Box_Fill_Transparency"]
                                    BoxFill.Visible = true
                                else
                                    ESPObjects[Player].BoxFill.Visible = false
                                end
                                
                                -- Box Outline (Black)
                                local BoxOutline = ESPObjects[Player].BoxOutline
                                BoxOutline.Size = Vector2.new(Width, Height)
                                BoxOutline.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
                                BoxOutline.Visible = true
                                
                                -- Box (Colored)
                                local Box = ESPObjects[Player].Box
                                Box.Size = Vector2.new(Width, Height)
                                Box.Position = Vector2.new(Vector.X - Width / 2, Vector.Y - Height / 2)
                                Box.Color = Library.Flags["ESP_Box_Color"].Color
                                Box.Visible = true
                            end
                        else
                            ESPObjects[Player].Box.Visible = false
                            ESPObjects[Player].BoxOutline.Visible = false
                            ESPObjects[Player].BoxFill.Visible = false
                            -- Hide all 3D box lines
                            ESPObjects[Player].TopFrontLine.Visible = false
                            ESPObjects[Player].TopBackLine.Visible = false
                            ESPObjects[Player].TopLeftLine.Visible = false
                            ESPObjects[Player].TopRightLine.Visible = false
                            ESPObjects[Player].BottomFrontLine.Visible = false
                            ESPObjects[Player].BottomBackLine.Visible = false
                            ESPObjects[Player].BottomLeftLine.Visible = false
                            ESPObjects[Player].BottomRightLine.Visible = false
                            ESPObjects[Player].FrontLeftLine.Visible = false
                            ESPObjects[Player].FrontRightLine.Visible = false
                            ESPObjects[Player].BackLeftLine.Visible = false
                            ESPObjects[Player].BackRightLine.Visible = false
                        end

                        -- Calculate Height and Width for other elements
                        local HeadVector = Camera:WorldToViewportPoint(Head.Position + Vector3.new(0, 0.5, 0))
                        local LegVector = Camera:WorldToViewportPoint(HumanoidRootPart.Position - Vector3.new(0, 3.5, 0))
                        local Height = math.abs(HeadVector.Y - LegVector.Y)
                        local Width = Height / 1.5

                        -- Health Bar
                        if Library.Flags["ESP_Health_Bar"] then
                            local Health, MaxHealth = GetHealth(Character)
                            local HealthPercentage = Health / MaxHealth
                            
                            local BarHeight = Height
                            local BarWidth = 2
                            local BarX = Vector.X - Width / 2 - 5
                            local BarY = Vector.Y - Height / 2

                            -- Outline
                            local Outline = ESPObjects[Player].HealthBarOutline
                            Outline.Size = Vector2.new(BarWidth + 2, BarHeight + 2)
                            Outline.Position = Vector2.new(BarX - 1, BarY - 1)
                            Outline.Visible = true

                            -- Health Bar
                            local Bar = ESPObjects[Player].HealthBar
                            Bar.Size = Vector2.new(BarWidth, BarHeight * HealthPercentage)
                            Bar.Position = Vector2.new(BarX, BarY + BarHeight * (1 - HealthPercentage))
                            
                            -- Health Bar Color Mode
                            if Library.Flags["ESP_Health_Bar_Mode"] == "Gradient" then
                                -- 3-color gradient: Red -> Yellow -> Green
                                local r, g, b
                                if HealthPercentage > 0.5 then
                                    -- Green to Yellow (100% to 50%)
                                    local t = (HealthPercentage - 0.5) * 2
                                    r = math.floor(255 * (1 - t))
                                    g = 255
                                    b = 0
                                else
                                    -- Yellow to Red (50% to 0%)
                                    local t = HealthPercentage * 2
                                    r = 255
                                    g = math.floor(255 * t)
                                    b = 0
                                end
                                Bar.Color = Color3.fromRGB(r, g, b)
                            else
                                Bar.Color = Library.Flags["ESP_Health_Bar_Color"].Color
                            end
                            
                            Bar.Visible = true
                        else
                            ESPObjects[Player].HealthBar.Visible = false
                            ESPObjects[Player].HealthBarOutline.Visible = false
                        end

                        -- Name ESP
                        if Library.Flags["ESP_Name"] then
                            local Name = ESPObjects[Player].Name
                            Name.Text = Player.Name
                            Name.Position = Vector2.new(Vector.X, Vector.Y - Height / 2 - 16)
                            Name.Color = Library.Flags["ESP_Name_Color"].Color
                            Name.Visible = true
                        else
                            ESPObjects[Player].Name.Visible = false
                        end

                        -- Distance ESP
                        if Library.Flags["ESP_Distance"] then
                            local DistanceText = ESPObjects[Player].Distance
                            DistanceText.Text = string.format("[%d studs]", math.floor(Distance))
                            DistanceText.Position = Vector2.new(Vector.X, Vector.Y + Height / 2 + 2)
                            DistanceText.Color = Library.Flags["ESP_Distance_Color"].Color
                            DistanceText.Visible = true
                        else
                            ESPObjects[Player].Distance.Visible = false
                        end

                        -- Weapon ESP
                        if Library.Flags["ESP_Weapon"] then
                            local WeaponText = ESPObjects[Player].Weapon
                            local Weapon = GetWeapon(Player)
                            WeaponText.Text = Weapon
                            WeaponText.Position = Vector2.new(Vector.X, Vector.Y + Height / 2 + 16)
                            WeaponText.Color = Library.Flags["ESP_Weapon_Color"].Color
                            WeaponText.Visible = true
                        else
                            ESPObjects[Player].Weapon.Visible = false
                        end

                        -- Tracer ESP
                        if Library.Flags["ESP_Tracer"] then
                            local Tracer = ESPObjects[Player].Tracer
                            local TracerOrigin = Library.Flags["ESP_Tracer_Origin"]
                            local ScreenSize = Camera.ViewportSize
                            
                            local FromY = TracerOrigin == "Top" and 0 or 
                                         TracerOrigin == "Middle" and ScreenSize.Y / 2 or 
                                         ScreenSize.Y
                            
                            Tracer.From = Vector2.new(ScreenSize.X / 2, FromY)
                            Tracer.To = Vector2.new(Vector.X, Vector.Y)
                            Tracer.Color = Library.Flags["ESP_Tracer_Color"].Color
                            Tracer.Visible = true
                        else
                            ESPObjects[Player].Tracer.Visible = false
                        end
                    else
                        for _, Drawing in pairs(ESPObjects[Player]) do
                            if type(Drawing) == "userdata" then
                                Drawing.Visible = false
                            end
                        end
                    end
                else
                    for _, Drawing in pairs(ESPObjects[Player]) do
                        if type(Drawing) == "userdata" then
                            Drawing.Visible = false
                        end
                    end
                end
            end
        end
    end

    -- Handle Player Removal
    Players.PlayerRemoving:Connect(function(Player)
        RemoveESP(Player)
    end)

    -- Main ESP Loop
    local ESPConnection
    
    local function ToggleESP(Enabled)
        if Enabled then
            ESPConnection = RunService.RenderStepped:Connect(UpdateESP)
        else
            if ESPConnection then
                ESPConnection:Disconnect()
            end
            for Player, _ in pairs(ESPObjects) do
                RemoveESP(Player)
            end
        end
    end

    -- UI Creation
    local ESPSection = VisualsTab:Section({Name = "ESP Settings", Side = 1})

    ESPSection:Toggle({Name = "Enabled", Flag = "ESP_Enabled", Default = false, Callback = function(Value)
        ToggleESP(Value)
    end})

    ESPSection:Toggle({Name = "Box ESP", Flag = "ESP_Box", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Box_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Dropdown({Name = "Box Type", Flag = "ESP_Box_Type", Default = "2D", Items = {"2D", "3D"}})

    ESPSection:Toggle({Name = "Box Fill", Flag = "ESP_Box_Fill", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Box_Fill_Color", Default = Color3.fromRGB(255, 255, 255)})
    
    ESPSection:Slider({Name = "Fill Transparency", Min = 0, Max = 1, Default = 0.3, Suffix = "", Decimals = 0.1, Flag = "ESP_Box_Fill_Transparency"})

    ESPSection:Toggle({Name = "Skeleton ESP", Flag = "ESP_Skeleton", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Skeleton_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Toggle({Name = "Name ESP", Flag = "ESP_Name", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Name_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Toggle({Name = "Weapon ESP", Flag = "ESP_Weapon", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Weapon_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Toggle({Name = "Distance ESP", Flag = "ESP_Distance", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Distance_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Toggle({Name = "Health Bar", Flag = "ESP_Health_Bar", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Health_Bar_Color", Default = Color3.fromRGB(0, 255, 0)})
    
    ESPSection:Dropdown({Name = "Health Bar Mode", Flag = "ESP_Health_Bar_Mode", Default = "Gradient", Items = {"Gradient", "Static"}})

    ESPSection:Toggle({Name = "Offscreen Arrows", Flag = "ESP_Offscreen", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Offscreen_Color", Default = Color3.fromRGB(255, 255, 255)})
    
    ESPSection:Slider({Name = "Arrow Size", Min = 5, Max = 30, Default = 15, Suffix = "px", Decimals = 1, Flag = "ESP_Offscreen_Size"})
    ESPSection:Slider({Name = "Arrow Distance", Min = 20, Max = 150, Default = 50, Suffix = "px", Decimals = 1, Flag = "ESP_Offscreen_Distance"})
    ESPSection:Slider({Name = "Arrow Transparency", Min = 0, Max = 1, Default = 0, Suffix = "", Decimals = 2, Flag = "ESP_Offscreen_Transparency"})

    ESPSection:Toggle({Name = "Tracer", Flag = "ESP_Tracer", Default = false}):Colorpicker({Name = "Color", Flag = "ESP_Tracer_Color", Default = Color3.fromRGB(255, 255, 255)})

    ESPSection:Dropdown({Name = "Tracer Origin", Flag = "ESP_Tracer_Origin", Default = "Bottom", Items = {"Top", "Middle", "Bottom"}})

    local ESPFiltersSection = VisualsTab:Section({Name = "ESP Filters", Side = 2})

    ESPFiltersSection:Toggle({Name = "Team Check", Flag = "ESP_Team_Check", Default = true})
    ESPFiltersSection:Toggle({Name = "Max Distance Check", Flag = "ESP_Max_Distance_Check", Default = false})
    ESPFiltersSection:Slider({Name = "Max Distance", Min = 50, Max = 2000, Default = 500, Suffix = " studs", Decimals = 1, Flag = "ESP_Max_Distance"})

    -- Local Player Visuals Section
    local LocalVisualsSection = VisualsTab:Section({Name = "Local Player", Side = 2})

    LocalVisualsSection:Toggle({Name = "China Hat", Flag = "China_Hat_Enabled", Default = false, Callback = function(Value)
        if Value then
            CreateChinaHat()
        else
            RemoveChinaHat()
        end
    end}):Colorpicker({Name = "Color", Flag = "China_Hat_Color", Default = Color3.fromRGB(255, 0, 0), Callback = function(Color)
        if ChinaHat then
            ChinaHat.BrickColor = BrickColor.new(Color)
        end
    end})
    
    LocalVisualsSection:Slider({Name = "Hat Size", Min = 1, Max = 8, Default = 4, Suffix = "x", Decimals = 0.1, Flag = "China_Hat_Size", Callback = function()
        if Library.Flags["China_Hat_Enabled"] then
            CreateChinaHat()
        end
    end})
    
    LocalVisualsSection:Slider({Name = "Hat Height", Min = 1, Max = 8, Default = 0.7, Suffix = "", Decimals = 0.1, Flag = "China_Hat_Height", Callback = function()
        if Library.Flags["China_Hat_Enabled"] then
            CreateChinaHat()
        end
    end})
    
    LocalVisualsSection:Slider({Name = "Hat Transparency", Min = 0, Max = 8, Default = 0, Suffix = "", Decimals = 0.1, Flag = "China_Hat_Transparency", Callback = function(Value)
        if ChinaHat then
            ChinaHat.Transparency = Value
        end
    end})
    
    LocalVisualsSection:Dropdown({Name = "Hat Material", Flag = "China_Hat_Material", Default = "Neon", Items = {"Neon", "ForceField"}, Callback = function(Value)
        if ChinaHat then
            ChinaHat.Material = Value == "Neon" and Enum.Material.Neon or Enum.Material.ForceField
        end
    end})
    
    LocalVisualsSection:Toggle({Name = "Spinning Hat", Flag = "China_Hat_Spin", Default = false, Callback = function()
        if Library.Flags["China_Hat_Enabled"] then
            CreateChinaHat()
        end
    end})
    
    LocalVisualsSection:Slider({Name = "Spin Speed", Min = 1, Max = 20, Default = 5, Suffix = "", Decimals = 1, Flag = "China_Hat_Spin_Speed", Callback = function()
        if Library.Flags["China_Hat_Enabled"] and Library.Flags["China_Hat_Spin"] then
            CreateChinaHat()
        end
    end})

    LocalVisualsSection:Dropdown({Name = "Material Changer", Flag = "Material_Changer", Default = "Default", Items = {"Default", "Foil", "ForceField"}, Callback = function(Value)
        ChangeMaterial(Value)
    end})

    -- Handle Character Respawn for Local Player Visuals
    LocalPlayer.CharacterAdded:Connect(function(Character)
        Character:WaitForChild("HumanoidRootPart")
        
        -- Reapply China Hat
        if Library.Flags["China_Hat_Enabled"] then
            wait(0.5)
            CreateChinaHat()
        end
        
        -- Reapply Material
        if Library.Flags["Material_Changer"] and Library.Flags["Material_Changer"] ~= "Default" then
            wait(0.5)
            ChangeMaterial(Library.Flags["Material_Changer"])
        end
    end)
end

































-- World Visuals
    local Lighting = game:GetService("Lighting")
    local OriginalLightingSettings = {
        Ambient = Lighting.Ambient,
        Brightness = Lighting.Brightness,
        ColorShift_Bottom = Lighting.ColorShift_Bottom,
        ColorShift_Top = Lighting.ColorShift_Top,
        EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale,
        EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale,
        OutdoorAmbient = Lighting.OutdoorAmbient,
        ClockTime = Lighting.ClockTime,
        GeographicLatitude = Lighting.GeographicLatitude,
        GlobalShadows = Lighting.GlobalShadows,
        Technology = Lighting.Technology
    }

    -- Store or create ColorCorrection
    local ColorCorrection = Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
    if not ColorCorrection then
        ColorCorrection = Instance.new("ColorCorrectionEffect")
        ColorCorrection.Parent = Lighting
    end
    
    local OriginalColorCorrection = {
        Brightness = ColorCorrection.Brightness,
        Contrast = ColorCorrection.Contrast,
        Saturation = ColorCorrection.Saturation,
        TintColor = ColorCorrection.TintColor,
        Enabled = ColorCorrection.Enabled
    }

    local WorldVisualsSection = VisualsTab:Section({Name = "World Visuals", Side = 1})

    -- Ambient Lighting
    WorldVisualsSection:Toggle({Name = "Custom Ambient", Flag = "World_Custom_Ambient", Default = false, Callback = function(Value)
        if not Value then
            Lighting.Ambient = OriginalLightingSettings.Ambient
            Lighting.OutdoorAmbient = OriginalLightingSettings.OutdoorAmbient
        end
    end}):Colorpicker({Name = "Color", Flag = "World_Ambient_Color", Default = Color3.fromRGB(128, 128, 128), Callback = function(Value)
        if Library.Flags["World_Custom_Ambient"] then
            Lighting.Ambient = Value
            Lighting.OutdoorAmbient = Value
        end
    end})

    -- Brightness
    WorldVisualsSection:Toggle({Name = "Custom Brightness", Flag = "World_Custom_Brightness", Default = false, Callback = function(Value)
        if not Value then
            Lighting.Brightness = OriginalLightingSettings.Brightness
        end
    end})
    
    WorldVisualsSection:Slider({Name = "Brightness", Min = 0, Max = 10, Default = 2, Decimals = 1, Flag = "World_Brightness", Callback = function(Value)
        if Library.Flags["World_Custom_Brightness"] then
            Lighting.Brightness = Value
        end
    end})

    -- Time of Day
    WorldVisualsSection:Toggle({Name = "Custom Time", Flag = "World_Custom_Time", Default = false, Callback = function(Value)
        if not Value then
            Lighting.ClockTime = OriginalLightingSettings.ClockTime
        end
    end})

    WorldVisualsSection:Slider({Name = "Time of Day", Min = 0, Max = 24, Default = 14, Decimals = 1, Flag = "World_Time", Callback = function(Value)
        if Library.Flags["World_Custom_Time"] then
            Lighting.ClockTime = Value
        end
    end})

    -- Color Correction
    local ColorCorrectionSection = VisualsTab:Section({Name = "Color Correction", Side = 2})

    ColorCorrectionSection:Toggle({Name = "Enable Color Correction", Flag = "World_Color_Correction", Default = false, Callback = function(Value)
        ColorCorrection.Enabled = Value
        if not Value then
            ColorCorrection.Brightness = OriginalColorCorrection.Brightness
            ColorCorrection.Contrast = OriginalColorCorrection.Contrast
            ColorCorrection.Saturation = OriginalColorCorrection.Saturation
            ColorCorrection.TintColor = OriginalColorCorrection.TintColor
        end
    end})

    ColorCorrectionSection:Slider({Name = "Saturation", Min = -15, Max = 50, Default = 0, Decimals = 2, Flag = "World_Saturation", Callback = function(Value)
        if Library.Flags["World_Color_Correction"] then
            ColorCorrection.Saturation = Value
        end
    end})

    ColorCorrectionSection:Slider({Name = "Contrast", Min = -15, Max = 50, Default = 0, Decimals = 2, Flag = "World_Contrast", Callback = function(Value)
        if Library.Flags["World_Color_Correction"] then
            ColorCorrection.Contrast = Value
        end
    end})

    ColorCorrectionSection:Slider({Name = "Brightness", Min = -15, Max = 50, Default = 0, Decimals = 2, Flag = "World_CC_Brightness", Callback = function(Value)
        if Library.Flags["World_Color_Correction"] then
            ColorCorrection.Brightness = Value
        end
    end})

    ColorCorrectionSection:Toggle({Name = "Tint Color", Flag = "World_Tint_Enabled", Default = false}):Colorpicker({Name = "Color", Flag = "World_Tint_Color", Default = Color3.fromRGB(255, 255, 255), Callback = function(Value)
        if Library.Flags["World_Color_Correction"] and Library.Flags["World_Tint_Enabled"] then
            ColorCorrection.TintColor = Value
        end
    end})









do -- Settings Tab
    local SettingsSection = SettingsTab:Section({Name = "Settings", Side = 2})
    local ConfigsSection = SettingsTab:Section({Name = "Profiles", Side = 1})

    for Index, Value in Library.Theme do 
        SettingsSection:Label({Name = Index, Alignment = "Left"}):Colorpicker({ Name = Index, Default = Value, Flag = "Theme"..Index, Callback = function(Color) 
            Library.Theme[Index] = Color
            Library:ChangeTheme(Index, Color)
        end})
    end

    SettingsSection:Label({Name = "Menu Keybind", Alignment = "Left"}):Keybind({Name = "Menu Keybind", Flag = "Menu Keybind", Default = Enum.KeyCode.RightControl, Mode = "Toggle", Callback = function(Value)
        Library.MenuKeybind = Library.Flags["Menu Keybind"].Key
    end})

    SettingsSection:Toggle({Name = "Watermark", Flag = "Watermark", Default = false, Callback = function(Value)
        Watermark:SetVisibility(Value)
    end})

    SettingsSection:Toggle({Name = "Keybind List", Flag = "Keybind List", Default = false, Callback = function(Value)
        KeybindList:SetVisibility(Value)
    end})

    SettingsSection:Dropdown({Name = "Tweening Style", Flag = "Tweening Style", Default = "Exponential", Items = {"Linear", "Sine", "Quad", "Cubic", "Quart", "Quint", "Exponential", "Circular", "Back", "Elastic", "Bounce"}, Callback = function(Value)
        Library.Tween.Style = Enum.EasingStyle[Value]
    end})

    SettingsSection:Dropdown({Name = "Tweening Direction", Flag = "Tweening Direction", Default = "Out", Items = {"In", "Out", "InOut"}, Callback = function(Value)
        Library.Tween.Direction = Enum.EasingDirection[Value]
    end})

    SettingsSection:Slider({Name = "Tweening Time", Min = 0, Max = 5, Default = 0.25, Decimals = 0.01, Flag = "Tweening Time", Callback = function(Value)
        Library.Tween.Time = Value
    end})

    SettingsSection:Button({Name = "Notification test", Callback = function()
        Library:Notification("This is a notification This is a notification This is a notification This is a notification", 5, Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255)))
    end})

    SettingsSection:Button({Name = "Unload library", Callback = function()
        Library:Unload()
    end})

    local ConfigName 
    local ConfigSelected

    local ConfigsListbox = ConfigsSection:Listbox({Items = { }, Name = "Configs", Flag = "Configs List", Callback = function(Value)
        ConfigSelected = Value
    end})

    ConfigsSection:Textbox({Name = "Config Name", Placeholder = ". .", Flag = "Config Name", Callback = function(Value)
        ConfigName = Value
    end})

    ConfigsSection:Button({Name = "Create Config", Callback = function()
        if not isfile(Library.Folders.Configs .. "/" .. ConfigName .. ".json") then
            writefile(Library.Folders.Configs .. "/" .. ConfigName .. ".json", Library:GetConfig())

            Library:RefreshConfigsList(ConfigsListbox)
        else
            Library:Notification("Config '" .. ConfigName .. ".json' already exists", 3, Color3.fromRGB(255, 0, 0))
            return
        end
    end})

    ConfigsSection:Button({Name = "Load Config", Callback = function()
        if ConfigSelected then
            Library:LoadConfig(readfile(Library.Folders.Configs .. "/" .. ConfigSelected))
        end

        Library:Thread(function()
            task.wait(0.1)

            for Index, Value in Library.Theme do 
                Library.Theme[Index] = Library.Flags["Theme"..Index].Color
                Library:ChangeTheme(Index, Library.Flags["Theme"..Index].Color)
            end    
        end)
    end})

    ConfigsSection:Button({Name = "Delete Config", Callback = function()
        if ConfigSelected then
            Library:DeleteConfig(ConfigSelected)

            Library:RefreshConfigsList(ConfigsListbox)
        end
    end})

    ConfigsSection:Button({Name = "Save Config", Callback = function()
        if ConfigSelected then
            Library:SaveConfig(ConfigSelected)
        end
    end})

    ConfigsSection:Button({Name = "Refresh Configs", Callback = function()
        Library:RefreshConfigsList(ConfigsListbox)
    end})

    Library:RefreshConfigsList(ConfigsListbox)
end

Library:Notification(string.format("welcome to meowbot.gg | Loaded in %.4f seconds", os.clock() - LoadingTick), 5, Library.Theme.Accent, {"rbxassetid://135757045959142", Color3.fromRGB(149, 255, 139)})
--
getgenv().Library = Library
return Library
